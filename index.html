<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AlgoNim - Strategic Nim on Algorand</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">

    <!-- Algorand SDK for mainnet transactions -->
    <script src="https://unpkg.com/algosdk@2.7.0/dist/browser/algosdk.min.js"></script>
    <!-- Pera Wallet Connect -->
    <script src="https://unpkg.com/@perawallet/connect@1.3.4/dist/index.umd.js"></script>
    <!-- Defly Wallet Connect -->
    <script src="https://unpkg.com/@blockshake/defly-connect@1.2.1/dist/index.umd.js"></script>
    <!-- Lute Wallet Connect -->
    <script src="https://unpkg.com/lute-connect@1.4.1/dist/index.umd.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --neon-cyan: #00f5ff;
            --neon-magenta: #ff006e;
            --neon-green: #39ff14;
            --neon-purple: #bf00ff;
            --neon-gold: #ffd700;
            --deep-space: #0d0221;
            --dark-matter: #0a0015;
            --card-glass: rgba(13, 2, 33, 0.9);
            --border-glow: rgba(0, 245, 255, 0.4);
        }

        body {
            font-family: 'Space Mono', monospace;
            background: var(--dark-matter);
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 245, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 110, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(191, 0, 255, 0.05) 0%, transparent 70%);
            pointer-events: none;
            z-index: 0;
            animation: pulse 8s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Grid overlay */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(rgba(0, 245, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 245, 255, 0.03) 1px, transparent 1px);
            background-size: 60px 60px;
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem;
            position: relative;
            z-index: 1;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 1.5rem;
            background: var(--card-glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-glow);
            border-radius: 12px;
            margin-bottom: 1rem;
            box-shadow: 0 0 40px rgba(0, 245, 255, 0.1);
            flex-shrink: 0;
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.6rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 3px;
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .logo-icon {
            font-size: 1.5rem;
        }

        .header-center {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header-btn {
            padding: 0.7rem 1.4rem;
            background: rgba(0, 245, 255, 0.1);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 25px;
            color: var(--neon-cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .header-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
        }

        /* Stats chips in header - match button size */
        .header-stats {
            display: none;
            align-items: center;
            gap: 0.5rem;
            margin-left: 0.5rem;
        }

        .header-stats.visible {
            display: flex;
        }

        .stat-chip {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.6rem 1rem;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            font-weight: 700;
        }

        .stat-chip.wins {
            color: var(--neon-green);
            border-color: rgba(57, 255, 20, 0.3);
        }

        .stat-chip.losses {
            color: var(--neon-magenta);
            border-color: rgba(255, 0, 110, 0.3);
        }

        .stat-chip.rating {
            color: var(--neon-gold);
            border-color: rgba(255, 215, 0, 0.3);
        }

        .stat-chip.earned {
            color: var(--neon-cyan);
            border-color: rgba(0, 245, 255, 0.3);
        }

        .stat-chip-label {
            opacity: 0.8;
        }

        /* Header icons for friends and challenges */
        .header-icons {
            display: none;
            align-items: center;
            gap: 0.5rem;
            margin-left: 0.5rem;
        }

        .header-icons.visible {
            display: flex;
        }

        .header-icon-btn {
            position: relative;
            padding: 0.6rem 1rem;
            background: rgba(0, 245, 255, 0.1);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 20px;
            color: var(--neon-cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .header-icon-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
        }

        .header-icon-btn .badge {
            position: absolute;
            top: -5px;
            right: -5px;
            min-width: 20px;
            height: 20px;
            padding: 0 6px;
            background: var(--neon-magenta);
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            font-weight: 700;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse-badge 2s infinite;
        }

        @keyframes pulse-badge {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .header-icon-btn .badge.hidden {
            display: none;
        }

        /* Tooltip */
        .tooltip {
            position: relative;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            padding: 0.5rem 0.8rem;
            background: rgba(0, 10, 20, 0.95);
            border: 1px solid var(--border-glow);
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 400;
            color: #ccc;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            z-index: 5000;
        }

        .tooltip:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Dropdown for challenges/friends */
        .header-dropdown {
            position: absolute;
            top: calc(100% + 10px);
            right: 0;
            min-width: 350px;
            max-height: 400px;
            overflow-y: auto;
            background: rgba(0, 10, 20, 0.98);
            border: 2px solid var(--neon-cyan);
            border-radius: 12px;
            padding: 1rem;
            display: none;
            z-index: 5000;
            box-shadow: 0 15px 60px rgba(0, 0, 0, 0.8);
        }

        .header-dropdown.active {
            display: block;
        }

        .dropdown-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: var(--neon-cyan);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(0, 245, 255, 0.3);
        }

        .dropdown-empty {
            text-align: center;
            color: #666;
            font-size: 0.85rem;
            padding: 2rem;
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.8rem;
            background: rgba(0, 245, 255, 0.05);
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 10px;
            margin-bottom: 0.6rem;
        }

        .dropdown-item:last-child {
            margin-bottom: 0;
        }

        .dropdown-item-info {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .dropdown-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .dropdown-name {
            font-size: 0.9rem;
            color: #fff;
            font-weight: 600;
        }

        .dropdown-detail {
            font-size: 0.75rem;
            color: var(--neon-gold);
            margin-top: 0.2rem;
        }

        .dropdown-actions {
            display: flex;
            gap: 0.5rem;
        }

        .dropdown-btn {
            padding: 0.5rem 0.8rem;
            border: none;
            border-radius: 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .dropdown-btn:hover {
            transform: scale(1.05);
        }

        .dropdown-btn.accept {
            background: linear-gradient(135deg, var(--neon-green), #00ccff);
            color: white;
        }

        .dropdown-btn.decline {
            background: transparent;
            border: 1px solid rgba(255, 0, 110, 0.5);
            color: var(--neon-magenta);
        }

        .dropdown-btn.challenge {
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            color: white;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .wallet-btn {
            padding: 0.7rem 1.8rem;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            border: none;
            border-radius: 30px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 1px;
        }

        .wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 30px rgba(0, 245, 255, 0.4);
        }

        .wallet-btn.connected {
            background: linear-gradient(135deg, var(--neon-green), #00ccff);
        }

        /* Main Layout - Fixed viewport, no scroll on game */
        .main-layout {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 1rem;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar - scrollable */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--neon-cyan);
            border-radius: 3px;
        }

        .panel {
            background: var(--card-glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-glow);
            border-radius: 12px;
            padding: 1rem;
        }

        .panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            color: var(--neon-cyan);
            margin-bottom: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Wager Selection - 4 columns but BIGGER */
        .wager-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }

        .wager-option {
            padding: 0.8rem 0.4rem;
            background: rgba(0, 245, 255, 0.05);
            border: 2px solid rgba(0, 245, 255, 0.2);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .wager-option:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: rgba(0, 245, 255, 0.5);
        }

        .wager-option.selected {
            background: rgba(0, 245, 255, 0.15);
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.2);
        }

        .wager-amount {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            color: var(--neon-cyan);
        }

        .wager-label {
            display: none;
        }

        .wager-players {
            display: none;
        }

        /* Game Mode Selector */
        .mode-selector {
            margin-top: 0.8rem;
            padding-top: 0.8rem;
            border-top: 1px solid rgba(0, 245, 255, 0.1);
        }

        .mode-label {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 0.5rem;
        }

        .mode-options {
            display: flex;
            gap: 0.6rem;
        }

        .mode-option {
            flex: 1;
            padding: 0.8rem 0.5rem;
            background: rgba(0, 245, 255, 0.05);
            border: 2px solid rgba(0, 245, 255, 0.2);
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .mode-option:hover {
            background: rgba(0, 245, 255, 0.1);
        }

        .mode-option.selected {
            background: rgba(0, 245, 255, 0.15);
            border-color: var(--neon-cyan);
        }

        .mode-name {
            display: block;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--neon-cyan);
        }

        .mode-time {
            display: block;
            font-size: 0.75rem;
            color: #888;
            margin-top: 0.25rem;
        }

        .mode-option.selected .mode-time {
            color: var(--neon-gold);
        }

        /* Timer Display - At top, centered, horizontal */
        .timer-display {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.6rem 1.5rem;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid var(--neon-cyan);
            border-radius: 30px;
            margin: 0.5rem auto 1rem;
            box-shadow: 0 0 25px rgba(0, 245, 255, 0.4);
        }

        .timer-label {
            font-size: 1.2rem;
        }

        .timer-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            font-weight: 900;
            color: var(--neon-cyan);
            text-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
        }

        .timer-ms {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            color: var(--neon-cyan);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .timer-ms.visible {
            opacity: 1;
        }

        .timer-mode-badge {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            padding: 0.2rem 0.5rem;
            background: var(--neon-cyan);
            color: var(--dark-matter);
            border-radius: 8px;
            font-weight: 700;
        }

        .timer-display.warning {
            border-color: var(--neon-gold);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
        }

        .timer-display.warning .timer-value,
        .timer-display.warning .timer-ms {
            color: var(--neon-gold);
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .timer-display.warning .timer-mode-badge {
            background: var(--neon-gold);
        }

        .timer-display.critical {
            border-color: var(--neon-magenta);
            box-shadow: 0 0 40px rgba(255, 0, 110, 0.6);
            animation: timerShake 0.1s ease-in-out infinite;
        }

        .timer-display.critical .timer-value,
        .timer-display.critical .timer-ms {
            color: var(--neon-magenta);
            text-shadow: 0 0 30px rgba(255, 0, 110, 0.8);
            animation: timerPulse 0.3s ease-in-out infinite;
        }

        .timer-display.critical .timer-mode-badge {
            background: var(--neon-magenta);
        }

        @keyframes timerPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        @keyframes timerShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .timer-mode-badge {
            font-size: 0.6rem;
            padding: 0.2rem 0.6rem;
            background: rgba(0, 245, 255, 0.2);
            border-radius: 10px;
            color: var(--neon-cyan);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 0.3rem;
        }

        /* Find Match Button */
        .btn-primary {
            width: 100%;
            padding: 0.8rem;
            margin-top: 0.8rem;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            border: none;
            border-radius: 25px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 1px;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 25px rgba(0, 245, 255, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            width: 100%;
            padding: 0.6rem;
            margin-top: 0.6rem;
            background: transparent;
            border: 2px solid var(--neon-cyan);
            border-radius: 25px;
            color: var(--neon-cyan);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 1px;
        }

        .btn-secondary:hover:not(:disabled) {
            background: rgba(0, 245, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
        }

        .btn-secondary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Invite Modal */
        .invite-modal {
            max-width: 420px;
        }

        .invite-form {
            text-align: left;
            margin: 1rem 0;
        }

        .invite-label {
            display: block;
            font-size: 0.8rem;
            color: var(--neon-cyan);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .invite-input {
            width: 100%;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 10px;
            color: #fff;
            font-family: 'Space Mono', monospace;
            font-size: 0.85rem;
            outline: none;
            transition: border-color 0.3s;
        }

        .invite-input:focus {
            border-color: var(--neon-cyan);
        }

        .invite-input::placeholder {
            color: #555;
        }

        .invite-settings {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
            padding: 0.8rem;
            background: rgba(0, 245, 255, 0.05);
            border-radius: 8px;
        }

        .invite-setting {
            text-align: center;
        }

        .invite-setting-label {
            display: block;
            font-size: 0.7rem;
            color: #888;
            margin-bottom: 0.2rem;
        }

        .invite-setting-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            color: var(--neon-cyan);
        }

        /* Pending Invites */
        .pending-invites-list {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }

        .invite-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.7rem;
            background: rgba(0, 245, 255, 0.05);
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 8px;
        }

        .invite-to {
            font-size: 0.8rem;
            color: #ccc;
        }

        .invite-details {
            font-size: 0.7rem;
            color: #666;
            margin-top: 0.2rem;
        }

        .invite-status {
            font-size: 0.65rem;
            padding: 0.25rem 0.6rem;
            border-radius: 10px;
            text-transform: uppercase;
            font-family: 'Orbitron', sans-serif;
        }

        .invite-status.pending {
            background: rgba(255, 215, 0, 0.2);
            color: var(--neon-gold);
        }

        .invite-status.accepted {
            background: rgba(57, 255, 20, 0.2);
            color: #39ff14;
        }

        .invite-status.declined {
            background: rgba(255, 0, 110, 0.2);
            color: var(--neon-magenta);
        }

        /* Incoming Invites */
        .incoming-invites-list {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .incoming-invite {
            padding: 1rem;
            background: rgba(57, 255, 20, 0.05);
            border: 1px solid rgba(57, 255, 20, 0.3);
            border-radius: 10px;
            animation: invitePulse 2s ease-in-out infinite;
        }

        @keyframes invitePulse {
            0%, 100% { box-shadow: 0 0 10px rgba(57, 255, 20, 0.1); }
            50% { box-shadow: 0 0 20px rgba(57, 255, 20, 0.3); }
        }

        .incoming-invite-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .incoming-invite-from {
            font-size: 0.85rem;
            color: #fff;
        }

        .incoming-invite-time {
            font-size: 0.7rem;
            color: #666;
        }

        .incoming-invite-details {
            font-size: 0.75rem;
            color: var(--neon-cyan);
            margin-bottom: 0.8rem;
        }

        .incoming-invite-actions {
            display: flex;
            gap: 0.5rem;
        }

        .btn-accept {
            flex: 1;
            padding: 0.5rem;
            background: linear-gradient(135deg, #39ff14, #00ccff);
            border: none;
            border-radius: 20px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-accept:hover { transform: scale(1.05); }

        .btn-decline {
            flex: 1;
            padding: 0.5rem;
            background: transparent;
            border: 1px solid rgba(255, 0, 110, 0.5);
            border-radius: 20px;
            color: var(--neon-magenta);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-decline:hover { background: rgba(255, 0, 110, 0.1); }

        /* Friends List */
        .friends-list {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            max-height: 100px;
            overflow-y: auto;
            margin-bottom: 0.5rem;
        }

        .friend-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.4rem 0.5rem;
            background: rgba(0, 245, 255, 0.05);
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 8px;
            transition: all 0.3s;
        }

        .friend-item:hover {
            background: rgba(0, 245, 255, 0.1);
        }

        .friend-info {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .friend-avatar {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
        }

        .friend-details {
            display: flex;
            flex-direction: column;
        }

        .friend-name {
            font-size: 0.65rem;
            color: #fff;
        }

        .friend-address {
            font-size: 0.55rem;
            color: #666;
        }

        .friend-status {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            font-size: 0.5rem;
        }

        .friend-status.online {
            color: #39ff14;
        }

        .friend-status.offline {
            color: #666;
        }

        .status-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: currentColor;
        }

        .friend-actions {
            display: flex;
            gap: 0.25rem;
        }

        .btn-challenge-friend {
            padding: 0.25rem 0.5rem;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            border: none;
            border-radius: 10px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.45rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-challenge-friend:hover { transform: scale(1.05); }

        .btn-remove-friend {
            padding: 0.25rem;
            background: transparent;
            border: none;
            color: #666;
            font-size: 0.6rem;
            cursor: pointer;
            transition: color 0.3s;
        }

        .btn-remove-friend:hover { color: var(--neon-magenta); }

        .btn-add-friend {
            width: 100%;
            padding: 0.4rem;
            background: transparent;
            border: 1px dashed rgba(0, 245, 255, 0.3);
            border-radius: 8px;
            color: var(--neon-cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-add-friend:hover {
            background: rgba(0, 245, 255, 0.1);
            border-style: solid;
        }

        .friend-count {
            font-size: 0.65rem;
            color: #666;
            font-weight: normal;
        }

        .friends-empty {
            text-align: center;
            color: #666;
            font-size: 0.8rem;
            padding: 1rem;
        }

        .btn-primary.searching {
            background: linear-gradient(135deg, var(--neon-gold), #ff8c00);
            animation: searchPulse 1.5s ease-in-out infinite;
        }

        @keyframes searchPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.6); }
        }

        /* Stats Panel */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .stat-item {
            text-align: center;
            padding: 0.8rem;
            background: rgba(0, 245, 255, 0.05);
            border-radius: 10px;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--neon-cyan);
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            margin-top: 0.3rem;
            text-transform: uppercase;
        }

        /* Main Game Area */
        .game-area {
            background: var(--card-glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-glow);
            border-radius: 12px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Welcome Screen */
        .welcome-screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 1rem;
            overflow: hidden;
        }

        .welcome-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta), var(--neon-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.8rem;
            letter-spacing: 4px;
        }

        .welcome-subtitle {
            font-size: 1rem;
            color: #aaa;
            max-width: 500px;
            line-height: 1.5;
            margin-bottom: 1.5rem;
        }

        .rules-box {
            background: rgba(0, 245, 255, 0.05);
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 12px;
            padding: 1.2rem;
            max-width: 550px;
            text-align: left;
        }

        .rules-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.95rem;
            color: var(--neon-cyan);
            margin-bottom: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .rules-list {
            list-style: none;
        }

        .rules-list li {
            padding: 0.4rem 0;
            padding-left: 1.5rem;
            position: relative;
            color: #ccc;
            line-height: 1.4;
        }

        .rules-list li::before {
            content: 'â–¸';
            position: absolute;
            left: 0;
            color: var(--neon-cyan);
        }

        .rules-list li strong {
            color: var(--neon-magenta);
        }

        /* Game Board */
        .game-board {
            flex: 1;
            display: none;
            flex-direction: column;
        }

        .game-board.active {
            display: flex;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(0, 245, 255, 0.2);
        }

        .game-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            color: var(--neon-cyan);
        }

        .pot-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            color: var(--neon-gold);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .players-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem 1.5rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .player-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .player-avatar.you {
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
        }

        .player-avatar.opponent {
            background: linear-gradient(135deg, var(--neon-magenta), #ff8c00);
        }

        .player-details {
            text-align: left;
        }

        .player-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
        }

        .player-address {
            font-size: 0.75rem;
            color: #888;
        }

        .vs-badge {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: var(--neon-magenta);
            padding: 0.5rem 1rem;
            background: rgba(255, 0, 110, 0.1);
            border-radius: 20px;
        }

        /* Nim Pyramid */
        .nim-pyramid {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            padding: 1.5rem;
            border-radius: 20px;
            transition: all 0.5s ease;
            position: relative;
        }

        /* Your turn - green glow effect */
        .nim-pyramid.your-turn {
            background: rgba(57, 255, 20, 0.03);
            box-shadow:
                0 0 30px rgba(57, 255, 20, 0.15),
                inset 0 0 60px rgba(57, 255, 20, 0.05);
            animation: pyramidGlowGreen 2s ease-in-out infinite;
        }

        .nim-pyramid.your-turn::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 22px;
            border: 2px solid transparent;
            background: linear-gradient(135deg, rgba(57, 255, 20, 0.5), transparent, rgba(57, 255, 20, 0.5)) border-box;
            -webkit-mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            animation: borderRotate 3s linear infinite;
        }

        @keyframes pyramidGlowGreen {
            0%, 100% { box-shadow: 0 0 30px rgba(57, 255, 20, 0.15), inset 0 0 60px rgba(57, 255, 20, 0.05); }
            50% { box-shadow: 0 0 50px rgba(57, 255, 20, 0.25), inset 0 0 80px rgba(57, 255, 20, 0.08); }
        }

        /* Opponent's turn - magenta glow effect */
        .nim-pyramid.opponent-turn {
            background: rgba(255, 0, 110, 0.03);
            box-shadow:
                0 0 30px rgba(255, 0, 110, 0.15),
                inset 0 0 60px rgba(255, 0, 110, 0.05);
        }

        .nim-pyramid.opponent-turn::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 22px;
            border: 2px solid rgba(255, 0, 110, 0.3);
            animation: opponentWaiting 1.5s ease-in-out infinite;
        }

        @keyframes opponentWaiting {
            0%, 100% { border-color: rgba(255, 0, 110, 0.3); }
            50% { border-color: rgba(255, 0, 110, 0.6); }
        }

        @keyframes borderRotate {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        .nim-row {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .row-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            color: var(--neon-cyan);
            min-width: 50px;
            text-align: right;
        }

        .sticks-container {
            display: flex;
            gap: 0.5rem;
            min-height: 60px;
            align-items: center;
        }

        .stick {
            width: 28px;
            height: 55px;
            background: linear-gradient(180deg, var(--neon-cyan) 0%, var(--neon-magenta) 100%);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 12px rgba(0, 245, 255, 0.4);
            position: relative;
        }

        .stick::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .stick:hover:not(.removed):not(.disabled) {
            transform: translateY(-6px);
            box-shadow: 0 8px 25px rgba(0, 245, 255, 0.6);
        }

        .stick.selected {
            background: linear-gradient(180deg, var(--neon-gold) 0%, #ff8c00 100%);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            transform: translateY(-4px);
        }

        .stick.removed {
            opacity: 0;
            background: #333;
            box-shadow: none;
            cursor: default;
            transform: scale(0.3) rotateX(90deg);
            pointer-events: none;
        }

        /* Stick removal animation */
        .stick.removing {
            animation: stickRemove 0.6s ease-out forwards;
        }

        @keyframes stickRemove {
            0% {
                transform: translateY(0) scale(1) rotateX(0);
                opacity: 1;
                box-shadow: 0 0 12px rgba(0, 245, 255, 0.4);
            }
            30% {
                transform: translateY(-20px) scale(1.2) rotateX(0);
                box-shadow: 0 0 40px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 0, 110, 0.6);
            }
            100% {
                transform: translateY(30px) scale(0) rotateX(90deg);
                opacity: 0;
                box-shadow: none;
            }
        }

        /* Particle burst effect container */
        .stick-particles {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: particleBurst 0.8s ease-out forwards;
        }

        @keyframes particleBurst {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        /* Glow ring effect on removal */
        .stick-glow-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid var(--neon-cyan);
            transform: translate(-50%, -50%);
            animation: glowRingExpand 0.5s ease-out forwards;
            pointer-events: none;
        }

        @keyframes glowRingExpand {
            0% {
                width: 20px;
                height: 20px;
                opacity: 1;
                border-width: 3px;
            }
            100% {
                width: 80px;
                height: 80px;
                opacity: 0;
                border-width: 1px;
            }
        }

        .stick.disabled {
            cursor: not-allowed;
        }

        /* Game Controls */
        .game-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(0, 245, 255, 0.2);
        }

        .turn-indicator {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            padding: 0.8rem 2rem;
            border-radius: 30px;
            letter-spacing: 2px;
        }

        .turn-indicator.your-turn {
            color: var(--neon-green);
            background: rgba(57, 255, 20, 0.1);
            border: 1px solid rgba(57, 255, 20, 0.3);
            animation: turnPulse 2s ease-in-out infinite;
        }

        .turn-indicator.opponent-turn {
            color: var(--neon-magenta);
            background: rgba(255, 0, 110, 0.1);
            border: 1px solid rgba(255, 0, 110, 0.3);
        }

        @keyframes turnPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(57, 255, 20, 0.2); }
            50% { box-shadow: 0 0 25px rgba(57, 255, 20, 0.4); }
        }

        .selection-info {
            font-size: 0.9rem;
            color: #888;
        }

        .btn-submit {
            padding: 1rem 3rem;
            background: linear-gradient(135deg, var(--neon-green), #00ccff);
            border: none;
            border-radius: 30px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 1px;
        }

        .btn-submit:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 30px rgba(57, 255, 20, 0.4);
        }

        .btn-submit:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--card-glass);
            border: 2px solid var(--neon-cyan);
            border-radius: 20px;
            padding: 3rem;
            text-align: center;
            max-width: 450px;
            box-shadow: 0 0 60px rgba(0, 245, 255, 0.3);
            animation: modalAppear 0.3s ease-out;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .modal-close:hover {
            background: rgba(255, 0, 110, 0.2);
            border-color: var(--neon-magenta);
            color: var(--neon-magenta);
        }

        @keyframes modalAppear {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .modal-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
        }

        .modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .modal-title.win {
            color: var(--neon-green);
            text-shadow: 0 0 30px rgba(57, 255, 20, 0.8);
            animation: winTitlePulse 0.5s ease-out;
        }

        @keyframes winTitlePulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        .modal-title.lose {
            color: var(--neon-magenta);
            text-shadow: 0 0 30px rgba(255, 0, 110, 0.8);
            animation: loseTitleShake 0.5s ease-out;
        }

        @keyframes loseTitleShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-10px); }
            40% { transform: translateX(10px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
        }

        .modal-amount {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
        }

        .modal-amount.positive {
            color: var(--neon-green);
            animation: amountBounce 0.6s ease-out 0.3s both;
        }

        .modal-amount.negative {
            color: var(--neon-magenta);
            animation: amountFade 0.4s ease-out 0.3s both;
        }

        @keyframes amountBounce {
            0% { transform: translateY(20px); opacity: 0; }
            60% { transform: translateY(-10px); }
            100% { transform: translateY(0); opacity: 1; }
        }

        @keyframes amountFade {
            0% { transform: translateY(20px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        .modal-message {
            color: #888;
            margin-bottom: 2rem;
        }

        /* Confetti container */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4000;
            overflow: hidden;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            animation: confettiFall linear forwards;
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-10vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(110vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Victory glow overlay */
        .victory-glow {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2999;
            animation: victoryFlash 0.8s ease-out;
        }

        @keyframes victoryFlash {
            0% {
                background: radial-gradient(circle at center, rgba(57, 255, 20, 0.4), transparent 70%);
            }
            100% {
                background: radial-gradient(circle at center, rgba(57, 255, 20, 0), transparent 70%);
            }
        }

        /* Defeat shake */
        .defeat-shake {
            animation: defeatShake 0.5s ease-out;
        }

        @keyframes defeatShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-20px); }
            30% { transform: translateX(20px); }
            50% { transform: translateX(-15px); }
            70% { transform: translateX(15px); }
            90% { transform: translateX(-5px); }
        }

        .btn-modal {
            padding: 1rem 3rem;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            border: none;
            border-radius: 30px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-modal:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 30px rgba(0, 245, 255, 0.4);
        }

        /* Wallet Modal */
        .wallet-modal {
            max-width: 400px;
        }

        .wallet-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .wallet-option {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1.2rem 1.5rem;
            background: rgba(0, 245, 255, 0.05);
            border: 2px solid rgba(0, 245, 255, 0.2);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .wallet-option:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--neon-cyan);
            transform: translateX(5px);
        }

        .wallet-option-icon {
            font-size: 2rem;
        }

        .wallet-option-name {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
        }

        .wallet-option-desc {
            font-size: 0.8rem;
            color: #888;
        }

        /* Status Messages */
        .status-message {
            font-size: 0.85rem;
            color: #888;
            text-align: center;
            margin-top: 1rem;
        }

        /* Lobby List */
        .lobby-list {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .lobby-empty {
            text-align: center;
            color: #666;
            font-size: 0.8rem;
            padding: 1rem;
        }

        .lobby-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.7rem 0.8rem;
            background: rgba(0, 245, 255, 0.05);
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .lobby-item:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: rgba(0, 245, 255, 0.4);
        }

        .lobby-player {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .lobby-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--neon-magenta), #ff8c00);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
        }

        .lobby-info {
            display: flex;
            flex-direction: column;
        }

        .lobby-address {
            font-size: 0.8rem;
            color: #ccc;
        }

        .lobby-rating {
            font-size: 0.7rem;
            color: var(--neon-cyan);
        }

        .lobby-wager {
            text-align: right;
        }

        .lobby-amount {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            color: var(--neon-gold);
        }

        .lobby-join {
            padding: 0.4rem 0.8rem;
            background: linear-gradient(135deg, var(--neon-green), #00ccff);
            border: none;
            border-radius: 15px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .lobby-join:hover {
            transform: scale(1.05);
        }

        .lobby-you {
            font-size: 0.7rem;
            color: var(--neon-green);
            font-family: 'Orbitron', sans-serif;
        }

        /* Active Games */
        .active-games-list {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .active-game-item {
            padding: 0.8rem 1rem;
            background: rgba(0, 245, 255, 0.05);
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .active-game-item:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: rgba(0, 245, 255, 0.4);
        }

        .active-game-item.your-turn {
            border-color: var(--neon-green);
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.2);
        }

        .active-game-item.their-turn {
            border-color: rgba(255, 0, 110, 0.3);
        }

        .active-game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
        }

        .active-game-opponent {
            font-size: 0.8rem;
            color: #ccc;
        }

        .active-game-pot {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            color: var(--neon-gold);
        }

        .active-game-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .active-game-turn {
            font-size: 0.7rem;
            font-family: 'Orbitron', sans-serif;
        }

        .active-game-turn.you {
            color: var(--neon-green);
        }

        .active-game-turn.them {
            color: #888;
        }

        .active-game-sticks {
            font-size: 0.7rem;
            color: #666;
        }

        .reminder-badge {
            font-size: 0.6rem;
            padding: 0.2rem 0.5rem;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid var(--neon-gold);
            border-radius: 10px;
            color: var(--neon-gold);
            margin-left: 0.5rem;
        }

        .waiting-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--neon-gold);
            font-size: 0.8rem;
        }

        .waiting-dot {
            width: 8px;
            height: 8px;
            background: var(--neon-gold);
            border-radius: 50%;
            animation: waitingPulse 1s ease-in-out infinite;
        }

        @keyframes waitingPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .sidebar .panel {
                flex: 1;
                min-width: 280px;
            }
        }

        @media (max-width: 600px) {
            .welcome-title {
                font-size: 2rem;
            }
            
            .header-right {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .stick {
                width: 28px;
                height: 55px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header>
            <div class="logo">
                <span class="logo-icon">â¬¢</span>
                ALGONIM
            </div>
            <div class="header-center">
                <button class="header-btn" id="rankingsBtn">RANKINGS</button>
                <button class="header-btn" id="tournamentsBtn">TOURNAMENTS</button>
                <div class="header-stats" id="headerStats">
                    <div class="stat-chip wins">
                        <span class="stat-chip-label">W</span>
                        <span id="headerWins">0</span>
                    </div>
                    <div class="stat-chip losses">
                        <span class="stat-chip-label">L</span>
                        <span id="headerLosses">0</span>
                    </div>
                    <div class="stat-chip rating">
                        <span>â­</span>
                        <span id="headerRating">1200</span>
                    </div>
                    <div class="stat-chip earned">
                        <span id="headerEarned">0.00</span>
                        <span class="stat-chip-label">Èº</span>
                    </div>
                </div>
                <div class="header-icons" id="headerIcons">
                    <!-- Incoming Challenges -->
                    <div class="header-icon-btn" id="challengesBtn">
                        CHALLENGES
                        <span class="badge hidden" id="challengesBadge">0</span>
                        <div class="header-dropdown" id="challengesDropdown">
                            <div class="dropdown-title">INCOMING CHALLENGES</div>
                            <div id="challengesDropdownList">
                                <div class="dropdown-empty">No pending challenges</div>
                            </div>
                        </div>
                    </div>
                    <!-- Friends -->
                    <div class="header-icon-btn tooltip" id="friendsBtn" data-tooltip="Send invite via Pera using friend's wallet">
                        FRIENDS
                        <span class="badge hidden" id="friendsBadge">0</span>
                        <div class="header-dropdown" id="friendsDropdown">
                            <div class="dropdown-title">FRIENDS</div>
                            <div id="friendsDropdownList">
                                <div class="dropdown-empty">No friends yet</div>
                            </div>
                            <button class="btn-add-friend" id="addFriendBtnHeader" style="margin-top:0.5rem;">+ ADD FRIEND</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="header-right">
                <button class="wallet-btn" id="connectBtn">CONNECT WALLET</button>
            </div>
        </header>

        <!-- Main Layout -->
        <div class="main-layout">
            <!-- Sidebar -->
            <div class="sidebar">
                <!-- Matchmaking Panel -->
                <div class="panel">
                    <div class="panel-title">MATCHMAKING</div>
                    
                    <div class="wager-grid">
                        <div class="wager-option selected" data-wager="0.0001">
                            <div class="wager-amount">0.0001</div>
                            <div class="wager-label">ALGO</div>
                            <div class="wager-players">Beginner</div>
                        </div>
                        <div class="wager-option" data-wager="0.001">
                            <div class="wager-amount">0.001</div>
                            <div class="wager-label">ALGO</div>
                            <div class="wager-players">Casual</div>
                        </div>
                        <div class="wager-option" data-wager="0.01">
                            <div class="wager-amount">0.01</div>
                            <div class="wager-label">ALGO</div>
                            <div class="wager-players">Ranked</div>
                        </div>
                        <div class="wager-option" data-wager="0.1">
                            <div class="wager-amount">0.1</div>
                            <div class="wager-label">ALGO</div>
                            <div class="wager-players">High Stakes</div>
                        </div>
                    </div>

                    <!-- Game Mode Selector -->
                    <div class="mode-selector">
                        <div class="mode-label">Game Mode:</div>
                        <div class="mode-options">
                            <div class="mode-option selected" data-mode="CASUAL">
                                <span class="mode-name">Casual</span>
                                <span class="mode-time">No limit</span>
                            </div>
                            <div class="mode-option" data-mode="SPEED">
                                <span class="mode-name">Speed</span>
                                <span class="mode-time">60s/turn</span>
                            </div>
                            <div class="mode-option" data-mode="BLITZ">
                                <span class="mode-name">Blitz</span>
                                <span class="mode-time">30s/turn</span>
                            </div>
                        </div>
                    </div>

                    <button class="btn-primary" id="findMatchBtn" disabled>
                        CONNECT WALLET FIRST
                    </button>
                    
                    <div class="status-message" id="matchStatus">
                        Connect your wallet to start playing
                    </div>
                </div>

                <!-- Pending Invites Panel -->
                <div class="panel" id="pendingInvitesPanel" style="display: none;">
                    <div class="panel-title">SENT INVITES</div>
                    <div class="pending-invites-list" id="pendingInvitesList">
                    </div>
                </div>

                <!-- Lobby Panel -->
                <div class="panel">
                    <div class="panel-title">OPEN MATCHES</div>
                    <div class="lobby-list" id="lobbyList">
                        <div class="lobby-empty">Connect wallet to see open matches</div>
                    </div>
                </div>

                <!-- Active Games Panel -->
                <div class="panel" id="activeGamesPanel" style="display: none;">
                    <div class="panel-title">YOUR ACTIVE GAMES</div>
                    <div class="active-games-list" id="activeGamesList">
                    </div>
                </div>
            </div>

            <!-- Game Area -->
            <div class="game-area">
                <!-- Welcome Screen -->
                <div class="welcome-screen" id="welcomeScreen">
                    <h1 class="welcome-title">NIM</h1>
                    <p class="welcome-subtitle">
                        The ancient game of strategy, reimagined on Algorand. 
                        Connect your wallet, wager crypto, and outsmart opponents worldwide.
                    </p>
                    
                    <div class="rules-box">
                        <div class="rules-title">âš¡ RULES OF THE GAME</div>
                        <ul class="rules-list">
                            <li>The board has <strong>4 rows</strong> with 1, 3, 5, and 7 sticks</li>
                            <li>Players take turns removing sticks</li>
                            <li>On your turn, remove <strong>any number</strong> of sticks from <strong>ONE row</strong></li>
                            <li>The player who takes the <strong>LAST stick LOSES</strong></li>
                            <li>Winner takes the <strong>entire pot</strong> ðŸ’°</li>
                        </ul>
                    </div>
                </div>

                <!-- Game Board -->
                <div class="game-board" id="gameBoard">
                    <div class="game-header">
                        <div class="game-title">GAME IN PROGRESS</div>
                        <div class="pot-display">
                            ðŸ† POT: <span id="potAmount">0.0002</span> ALGO
                        </div>
                    </div>

                    <div class="players-bar">
                        <div class="player-info">
                            <div class="player-avatar you">ðŸ‘¤</div>
                            <div class="player-details">
                                <div class="player-name">YOU</div>
                                <div class="player-address" id="yourAddress">Connect wallet...</div>
                            </div>
                        </div>
                        <div class="vs-badge">VS</div>
                        <div class="player-info">
                            <div class="player-details" style="text-align: right;">
                                <div class="player-name">OPPONENT</div>
                                <div class="player-address" id="opponentAddress">Waiting...</div>
                            </div>
                            <div class="player-avatar opponent">ðŸ‘¤</div>
                        </div>
                    </div>

                    <!-- TIMER AT TOP -->
                    <div class="timer-display" id="timerDisplay" style="display: none;">
                        <span class="timer-label">â±ï¸</span>
                        <span class="timer-value" id="timerValue">0:30</span>
                        <span class="timer-ms" id="timerMs">.00</span>
                        <span class="timer-mode-badge" id="timerModeBadge">BLITZ</span>
                    </div>

                    <div class="nim-pyramid" id="nimPyramid">
                        <!-- Row 1: 1 stick -->
                        <div class="nim-row">
                            <span class="row-label">Row 1</span>
                            <div class="sticks-container" data-row="0">
                                <div class="stick" data-row="0" data-index="0"></div>
                            </div>
                        </div>
                        <!-- Row 2: 3 sticks -->
                        <div class="nim-row">
                            <span class="row-label">Row 2</span>
                            <div class="sticks-container" data-row="1">
                                <div class="stick" data-row="1" data-index="0"></div>
                                <div class="stick" data-row="1" data-index="1"></div>
                                <div class="stick" data-row="1" data-index="2"></div>
                            </div>
                        </div>
                        <!-- Row 3: 5 sticks -->
                        <div class="nim-row">
                            <span class="row-label">Row 3</span>
                            <div class="sticks-container" data-row="2">
                                <div class="stick" data-row="2" data-index="0"></div>
                                <div class="stick" data-row="2" data-index="1"></div>
                                <div class="stick" data-row="2" data-index="2"></div>
                                <div class="stick" data-row="2" data-index="3"></div>
                                <div class="stick" data-row="2" data-index="4"></div>
                            </div>
                        </div>
                        <!-- Row 4: 7 sticks -->
                        <div class="nim-row">
                            <span class="row-label">Row 4</span>
                            <div class="sticks-container" data-row="3">
                                <div class="stick" data-row="3" data-index="0"></div>
                                <div class="stick" data-row="3" data-index="1"></div>
                                <div class="stick" data-row="3" data-index="2"></div>
                                <div class="stick" data-row="3" data-index="3"></div>
                                <div class="stick" data-row="3" data-index="4"></div>
                                <div class="stick" data-row="3" data-index="5"></div>
                                <div class="stick" data-row="3" data-index="6"></div>
                            </div>
                        </div>
                    </div>

                    <div class="game-controls">
                        <div class="turn-indicator your-turn" id="turnIndicator">
                            YOUR TURN
                        </div>
                        <div class="selection-info" id="selectionInfo">
                            Click sticks to select (from one row only)
                        </div>
                        <button class="btn-submit" id="submitBtn" disabled>
                            SUBMIT MOVE
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Wallet Selection Modal -->
    <div class="modal-overlay" id="walletModal">
        <div class="modal wallet-modal">
            <div class="modal-icon">ðŸ”</div>
            <h2 class="modal-title" style="color: var(--neon-cyan); font-size: 1.5rem;">SELECT WALLET</h2>
            
            <div class="wallet-options">
                <div class="wallet-option" data-wallet="pera">
                    <span class="wallet-option-icon">ðŸ“±</span>
                    <div>
                        <div class="wallet-option-name">Pera Wallet</div>
                        <div class="wallet-option-desc">Mobile & Web</div>
                    </div>
                </div>
                <div class="wallet-option" data-wallet="defly">
                    <span class="wallet-option-icon">ðŸ¦‹</span>
                    <div>
                        <div class="wallet-option-name">Defly</div>
                        <div class="wallet-option-desc">DeFi Focused</div>
                    </div>
                </div>
                <div class="wallet-option" data-wallet="exodus">
                    <span class="wallet-option-icon">ðŸ’Ž</span>
                    <div>
                        <div class="wallet-option-name">Exodus</div>
                        <div class="wallet-option-desc">Multi-Chain</div>
                    </div>
                </div>
                <div class="wallet-option" data-wallet="lute">
                    <span class="wallet-option-icon">ðŸŽ¸</span>
                    <div>
                        <div class="wallet-option-name">Lute</div>
                        <div class="wallet-option-desc">Desktop App</div>
                    </div>
                </div>
            </div>
            
            <button class="btn-modal" id="closeWalletModal" style="background: #333;">CANCEL</button>
        </div>
    </div>

    <!-- Game Result Modal -->
    <div class="modal-overlay" id="resultModal">
        <div class="modal">
            <button class="modal-close" id="closeResultX">&times;</button>
            <div class="modal-icon" id="resultIcon">ðŸŽ‰</div>
            <h2 class="modal-title win" id="resultTitle">YOU WIN!</h2>
            <div class="modal-amount positive" id="resultAmount">+0.0002 ALGO</div>
            <p class="modal-message" id="resultMessage">Your opponent took the last stick!</p>
            <button class="btn-modal" id="playAgainBtn">PLAY AGAIN</button>
        </div>
    </div>

    <!-- Invite Modal -->
    <div class="modal-overlay" id="inviteModal">
        <div class="modal invite-modal">
            <button class="modal-close" id="closeInviteX">&times;</button>
            <div class="modal-icon">ðŸ“¨</div>
            <h2 class="modal-title" style="color: var(--neon-cyan); font-size: 1.5rem;">INVITE PLAYER</h2>
            <p style="color: #888; margin-bottom: 1.5rem; font-size: 0.9rem;">
                Send a game invite to any Algorand wallet.<br>
                They'll get a notification in their wallet's transaction history.
            </p>
            
            <div class="invite-form">
                <label class="invite-label">Wallet Address</label>
                <input type="text" 
                       id="inviteAddressInput" 
                       class="invite-input" 
                       placeholder="ALGO..."
                       maxlength="58">
                
                <div class="invite-settings">
                    <div class="invite-setting">
                        <span class="invite-setting-label">Wager:</span>
                        <span class="invite-setting-value" id="inviteWagerDisplay">0.0001 ALGO</span>
                    </div>
                    <div class="invite-setting">
                        <span class="invite-setting-label">Mode:</span>
                        <span class="invite-setting-value" id="inviteModeDisplay">Casual</span>
                    </div>
                </div>
                
                <p style="color: #666; font-size: 0.75rem; margin: 1rem 0;">
                    ðŸ’¡ Uses your selected wager & mode settings
                </p>
            </div>
            
            <div style="display: flex; gap: 1rem; justify-content: center;">
                <button class="btn-modal" style="background: #333;" id="cancelInviteBtn">CANCEL</button>
                <button class="btn-modal" id="sendInviteBtn">SEND INVITE</button>
            </div>
        </div>
    </div>

    <!-- Add Friend Modal -->
    <div class="modal-overlay" id="addFriendModal">
        <div class="modal invite-modal">
            <button class="modal-close" id="closeAddFriendX">&times;</button>
            <div class="modal-icon">ðŸ‘¥</div>
            <h2 class="modal-title" style="color: var(--neon-cyan); font-size: 1.5rem;">ADD FRIEND</h2>
            <p style="color: #888; margin-bottom: 1.5rem; font-size: 0.9rem;">
                Add a player by their wallet address.<br>
                Challenge friends directly anytime!
            </p>
            
            <div class="invite-form">
                <label class="invite-label">Friend's Wallet Address</label>
                <input type="text" 
                       id="friendAddressInput" 
                       class="invite-input" 
                       placeholder="ALGO..."
                       maxlength="58">
                
                <label class="invite-label" style="margin-top: 1rem;">Nickname (optional)</label>
                <input type="text" 
                       id="friendNicknameInput" 
                       class="invite-input" 
                       placeholder="e.g. CryptoKing"
                       maxlength="20">
            </div>
            
            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1.5rem;">
                <button class="btn-modal" style="background: #333;" id="cancelAddFriendBtn">CANCEL</button>
                <button class="btn-modal" id="confirmAddFriendBtn">ADD FRIEND</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // ALGORAND CONFIGURATION
        // ============================================
        const ALGO_CONFIG = {
            // Mainnet configuration
            NETWORK: 'mainnet',
            GENESIS_ID: 'mainnet-v1.0',
            GENESIS_HASH: 'wGHE2Pwdvd7S12BL5FaOP20EGYesN73ktiC1qzkkit8=',
            ALGOD_SERVER: 'https://mainnet-api.algonode.cloud',
            ALGOD_PORT: '',
            ALGOD_TOKEN: '',
            INDEXER_SERVER: 'https://mainnet-idx.algonode.cloud',

            // Worker API (update with your deployed worker URL)
            WORKER_URL: 'https://algonim-worker.mitchhall16.workers.dev',

            // Minimum wager amounts (in ALGO)
            MIN_WAGER: 0.001,
            MAX_WAGER: 0.1
        };

        // Initialize Algorand client
        const algodClient = new algosdk.Algodv2(
            ALGO_CONFIG.ALGOD_TOKEN,
            ALGO_CONFIG.ALGOD_SERVER,
            ALGO_CONFIG.ALGOD_PORT
        );

        // ============================================
        // WALLET PROVIDERS
        // ============================================
        // Initialize all wallet providers
        const walletProviders = {
            pera: null,
            defly: null,
            lute: null
        };

        // Active wallet type
        let activeWalletType = null;

        // Initialize Pera Wallet
        try {
            walletProviders.pera = new PeraWalletConnect();
        } catch (e) {
            console.warn('Pera Wallet SDK not loaded:', e);
        }

        // Initialize Defly Wallet
        try {
            if (typeof DeflyWalletConnect !== 'undefined') {
                walletProviders.defly = new DeflyWalletConnect();
            }
        } catch (e) {
            console.warn('Defly Wallet SDK not loaded:', e);
        }

        // Initialize Lute Wallet
        try {
            if (typeof LuteConnect !== 'undefined') {
                walletProviders.lute = new LuteConnect('AlgoNim');
            }
        } catch (e) {
            console.warn('Lute Wallet SDK not loaded:', e);
        }

        // Auto-reconnect on page load
        async function attemptAutoReconnect() {
            // Try Pera first
            if (walletProviders.pera) {
                try {
                    const accounts = await walletProviders.pera.reconnectSession();
                    if (accounts && accounts.length > 0) {
                        activeWalletType = 'pera';
                        await handleWalletConnected(accounts[0], 'pera');
                        return;
                    }
                } catch (e) {
                    console.log('No Pera session to reconnect');
                }
            }

            // Try Defly
            if (walletProviders.defly) {
                try {
                    const accounts = await walletProviders.defly.reconnectSession();
                    if (accounts && accounts.length > 0) {
                        activeWalletType = 'defly';
                        await handleWalletConnected(accounts[0], 'defly');
                        return;
                    }
                } catch (e) {
                    console.log('No Defly session to reconnect');
                }
            }
        }

        // Run auto-reconnect
        attemptAutoReconnect();

        // ============================================
        // GAME STATE
        // ============================================
        const GameState = {
            wallet: {
                connected: false,
                address: null,
                balance: 0
            },
            stats: {
                wins: 0,
                losses: 0,
                rating: 1200,
                earnings: 0
            },
            match: {
                active: false,
                gameId: null,
                opponent: null,
                wager: 0.0001,
                pot: 0,
                isMyTurn: false,
                gameMode: 'CASUAL',           // CASUAL, SPEED, or BLITZ
                turnStartTime: null,          // When current turn started
                timerInterval: null           // Timer update interval
            },
            lobby: {
                waiting: false,
                waitingId: null,
                players: [],
                selectedMode: 'CASUAL'        // Mode for new games
            },
            // Track multiple active games
            activeGames: [],
            currentGameIndex: null,
            // Friends & invites
            friends: [],
            incomingInvites: [],
            pendingInvites: [],
            // Track each stick individually: true = present, false = removed
            board: [
                [true],                                           // Row 0: 1 stick
                [true, true, true],                               // Row 1: 3 sticks
                [true, true, true, true, true],                   // Row 2: 5 sticks
                [true, true, true, true, true, true, true]        // Row 3: 7 sticks
            ],
            selection: {
                row: null,
                sticks: []
            }
        };

        // Simulated lobby players (in production this comes from the server)
        const simulatedLobbyPlayers = [
            { id: 1, address: 'ALGO7X9K2M...', rating: 1150, wager: 0.0001 },
            { id: 2, address: 'ALGOP3QR8N...', rating: 1340, wager: 0.001 },
            { id: 3, address: 'ALGOWZ5Y1T...', rating: 1520, wager: 0.01 },
            { id: 4, address: 'ALGOKL4H9D...', rating: 980, wager: 0.0001 },
            { id: 5, address: 'ALGOMN7V2X...', rating: 1680, wager: 0.1 },
        ];

        // Reminder system config
        const REMINDER_CONFIG = {
            enabled: true,
            reminderDelayMs: 30 * 60 * 1000,      // 30 minutes - send reminder
            abandonDelayMs: 3 * 24 * 60 * 60 * 1000, // 3 days - auto-forfeit
            minAlgoAmount: 0.001,                  // ALGO to send with reminder note
            deployerWallet: 'ALGONIM_DEPLOYER_WALLET' // Server wallet sends reminders
        };

        // Game timing modes
        const GAME_MODES = {
            CASUAL: {
                name: 'Casual',
                turnTimeMs: null,                  // No time limit
                reminderMs: 30 * 60 * 1000,       // 30 min reminder
                abandonMs: 3 * 24 * 60 * 60 * 1000 // 3 day abandon
            },
            SPEED: {
                name: 'Speed',
                turnTimeMs: 60 * 1000,            // 1 minute per turn
                reminderMs: 30 * 1000,            // 30 sec warning
                abandonMs: 60 * 1000              // Auto-forfeit at 1 min
            },
            BLITZ: {
                name: 'Blitz',
                turnTimeMs: 30 * 1000,            // 30 seconds per turn
                reminderMs: 15 * 1000,            // 15 sec warning
                abandonMs: 30 * 1000              // Auto-forfeit at 30 sec
            }
        };

        // Penalty points
        const PENALTIES = {
            LOSS: -15,           // Normal loss
            ABANDON: -10,        // Abandon after 3 days (less than loss)
            TIMEOUT: -12,        // Timeout in speed mode
            WIN: 20,             // Normal win
            WIN_BY_ABANDON: 15,  // Win because opponent abandoned
            WIN_BY_TIMEOUT: 15   // Win because opponent timed out
        };

        // ============================================
        // DOM ELEMENTS
        // ============================================
        const DOM = {
            // Header
            connectBtn: document.getElementById('connectBtn'),
            
            // Matchmaking
            findMatchBtn: document.getElementById('findMatchBtn'),
            matchStatus: document.getElementById('matchStatus'),
            wagerOptions: document.querySelectorAll('.wager-option'),
            modeOptions: document.querySelectorAll('.mode-option'),
            lobbyList: document.getElementById('lobbyList'),
            activeGamesPanel: document.getElementById('activeGamesPanel'),
            activeGamesList: document.getElementById('activeGamesList'),
            timerDisplay: document.getElementById('timerDisplay'),
            timerValue: document.getElementById('timerValue'),
            timerMs: document.getElementById('timerMs'),
            timerModeBadge: document.getElementById('timerModeBadge'),
            
            // Invite system
            inviteModal: document.getElementById('inviteModal'),
            closeInviteX: document.getElementById('closeInviteX'),
            inviteAddressInput: document.getElementById('inviteAddressInput'),
            inviteWagerDisplay: document.getElementById('inviteWagerDisplay'),
            inviteModeDisplay: document.getElementById('inviteModeDisplay'),
            cancelInviteBtn: document.getElementById('cancelInviteBtn'),
            sendInviteBtn: document.getElementById('sendInviteBtn'),
            pendingInvitesPanel: document.getElementById('pendingInvitesPanel'),
            pendingInvitesList: document.getElementById('pendingInvitesList'),
            
            // Friends system - now in header dropdowns
            headerIcons: document.getElementById('headerIcons'),
            challengesBtn: document.getElementById('challengesBtn'),
            challengesBadge: document.getElementById('challengesBadge'),
            challengesDropdown: document.getElementById('challengesDropdown'),
            challengesDropdownList: document.getElementById('challengesDropdownList'),
            friendsBtn: document.getElementById('friendsBtn'),
            friendsBadge: document.getElementById('friendsBadge'),
            friendsDropdown: document.getElementById('friendsDropdown'),
            friendsDropdownList: document.getElementById('friendsDropdownList'),
            addFriendBtnHeader: document.getElementById('addFriendBtnHeader'),
            addFriendModal: document.getElementById('addFriendModal'),
            closeAddFriendX: document.getElementById('closeAddFriendX'),
            friendAddressInput: document.getElementById('friendAddressInput'),
            friendNicknameInput: document.getElementById('friendNicknameInput'),
            cancelAddFriendBtn: document.getElementById('cancelAddFriendBtn'),
            confirmAddFriendBtn: document.getElementById('confirmAddFriendBtn'),
            
            // Stats (now in header)
            headerStats: document.getElementById('headerStats'),
            statWins: document.getElementById('headerWins'),
            statLosses: document.getElementById('headerLosses'),
            statRating: document.getElementById('headerRating'),
            statEarnings: document.getElementById('headerEarned'),
            
            // Screens
            welcomeScreen: document.getElementById('welcomeScreen'),
            gameBoard: document.getElementById('gameBoard'),
            
            // Game
            potAmount: document.getElementById('potAmount'),
            yourAddress: document.getElementById('yourAddress'),
            opponentAddress: document.getElementById('opponentAddress'),
            turnIndicator: document.getElementById('turnIndicator'),
            selectionInfo: document.getElementById('selectionInfo'),
            submitBtn: document.getElementById('submitBtn'),
            sticks: document.querySelectorAll('.stick'),
            
            // Modals
            walletModal: document.getElementById('walletModal'),
            closeWalletModal: document.getElementById('closeWalletModal'),
            walletOptions: document.querySelectorAll('.wallet-option'),
            resultModal: document.getElementById('resultModal'),
            resultIcon: document.getElementById('resultIcon'),
            resultTitle: document.getElementById('resultTitle'),
            resultAmount: document.getElementById('resultAmount'),
            resultMessage: document.getElementById('resultMessage'),
            playAgainBtn: document.getElementById('playAgainBtn'),
            closeResultX: document.getElementById('closeResultX')
        };

        // ============================================
        // WALLET FUNCTIONS
        // ============================================
        function openWalletModal() {
            DOM.walletModal.classList.add('active');
        }

        function closeWalletModal() {
            DOM.walletModal.classList.remove('active');
        }

        // Fetch account balance from Algorand mainnet
        async function fetchAccountBalance(address) {
            try {
                const accountInfo = await algodClient.accountInformation(address).do();
                // Balance is in microAlgos, convert to ALGO
                return accountInfo.amount / 1000000;
            } catch (error) {
                console.error('Error fetching balance:', error);
                return 0;
            }
        }

        // Handle successful wallet connection
        async function handleWalletConnected(address, walletType) {
            GameState.wallet.connected = true;
            GameState.wallet.address = address;
            GameState.wallet.type = walletType;
            activeWalletType = walletType;

            // Fetch real balance
            GameState.wallet.balance = await fetchAccountBalance(address);

            // Update UI
            const walletIcon = { pera: 'ðŸ“±', defly: 'ðŸ¦‹', lute: 'ðŸŽ¸', exodus: 'ðŸ’Ž' }[walletType] || 'ðŸ”';
            DOM.connectBtn.textContent = `${walletIcon} ${address.substring(0, 4)}...${address.substring(54)}`;
            DOM.connectBtn.classList.add('connected');
            DOM.yourAddress.textContent = address.substring(0, 8) + '...';
            DOM.headerStats.classList.add('visible');
            DOM.headerIcons.classList.add('visible');

            DOM.findMatchBtn.disabled = false;
            DOM.findMatchBtn.textContent = 'FIND MATCH';
            DOM.matchStatus.textContent = `Ready to play! Balance: ${GameState.wallet.balance.toFixed(4)} ALGO`;

            // Fetch player stats from server
            fetchPlayerStats(address);

            // Render lobby with available matches
            renderLobby();
            renderFriendsDropdown();

            console.log(`Connected via ${walletType} to mainnet: ${address} (${GameState.wallet.balance.toFixed(4)} ALGO)`);
        }

        // Handle wallet disconnection
        function handleWalletDisconnected() {
            GameState.wallet.connected = false;
            GameState.wallet.address = null;
            GameState.wallet.balance = 0;
            GameState.wallet.type = null;
            activeWalletType = null;

            DOM.connectBtn.textContent = 'CONNECT';
            DOM.connectBtn.classList.remove('connected');
            DOM.headerStats.classList.remove('visible');
            DOM.headerIcons.classList.remove('visible');
            DOM.findMatchBtn.disabled = true;
            DOM.findMatchBtn.textContent = 'Connect Wallet First';
            DOM.matchStatus.textContent = 'Connect your wallet to play';

            console.log('Wallet disconnected');
        }

        // Connect to wallet
        async function connectWallet(walletType) {
            closeWalletModal();
            DOM.matchStatus.textContent = `Connecting to ${walletType}...`;

            try {
                let accounts = [];

                switch (walletType) {
                    case 'pera':
                        // Pera Wallet connection
                        if (!walletProviders.pera) {
                            throw new Error('Pera Wallet SDK not loaded');
                        }
                        accounts = await walletProviders.pera.connect();
                        // Set up disconnect listener
                        walletProviders.pera.connector?.on('disconnect', handleWalletDisconnected);
                        break;

                    case 'defly':
                        // Defly Wallet connection
                        if (!walletProviders.defly) {
                            throw new Error('Defly Wallet SDK not loaded. Please install Defly app.');
                        }
                        accounts = await walletProviders.defly.connect();
                        // Set up disconnect listener
                        walletProviders.defly.connector?.on('disconnect', handleWalletDisconnected);
                        break;

                    case 'lute':
                        // Lute Wallet connection
                        if (!walletProviders.lute) {
                            throw new Error('Lute Wallet SDK not loaded');
                        }
                        // Lute requires genesis ID for connection
                        accounts = await walletProviders.lute.connect(ALGO_CONFIG.GENESIS_ID);
                        break;

                    case 'exodus':
                        // Exodus browser extension
                        if (typeof window.exodus === 'undefined' || !window.exodus.algorand) {
                            throw new Error('Exodus Wallet not detected. Please install the Exodus browser extension.');
                        }
                        accounts = await window.exodus.algorand.connect();
                        break;

                    default:
                        throw new Error('Unknown wallet type');
                }

                if (accounts && accounts.length > 0) {
                    await handleWalletConnected(accounts[0], walletType);
                } else {
                    throw new Error('No accounts returned from wallet');
                }

            } catch (error) {
                console.error('Wallet connection error:', error);

                // Handle user cancellation
                if (error.message?.includes('cancelled') ||
                    error.message?.includes('rejected') ||
                    error.message?.includes('CONNECT_MODAL_CLOSED') ||
                    error.data?.type === 'CONNECT_MODAL_CLOSED') {
                    DOM.matchStatus.textContent = 'Connection cancelled. Try again!';
                } else {
                    DOM.matchStatus.textContent = error.message || 'Connection failed. Please try again.';
                }

                // Re-open wallet modal for retry
                setTimeout(() => {
                    if (!GameState.wallet.connected) {
                        openWalletModal();
                    }
                }, 2000);
            }
        }

        // Disconnect wallet
        async function disconnectWallet() {
            try {
                // Disconnect from active wallet provider
                switch (activeWalletType) {
                    case 'pera':
                        if (walletProviders.pera) await walletProviders.pera.disconnect();
                        break;
                    case 'defly':
                        if (walletProviders.defly) await walletProviders.defly.disconnect();
                        break;
                    case 'lute':
                        if (walletProviders.lute) walletProviders.lute.disconnect();
                        break;
                }
            } catch (error) {
                console.error('Disconnect error:', error);
            }
            handleWalletDisconnected();
        }

        // ============================================
        // TRANSACTION SIGNING
        // ============================================

        // Sign transaction with active wallet
        async function signTransaction(txn) {
            if (!activeWalletType || !GameState.wallet.connected) {
                throw new Error('No wallet connected');
            }

            const encodedTxn = algosdk.encodeUnsignedTransaction(txn);

            switch (activeWalletType) {
                case 'pera':
                    const peraSignedTxns = await walletProviders.pera.signTransaction([[{ txn: encodedTxn }]]);
                    return peraSignedTxns[0];

                case 'defly':
                    const deflySignedTxns = await walletProviders.defly.signTransaction([[{ txn: encodedTxn }]]);
                    return deflySignedTxns[0];

                case 'lute':
                    const luteSignedTxns = await walletProviders.lute.signTxns([{ txn: encodedTxn }]);
                    return luteSignedTxns[0];

                case 'exodus':
                    const exodusResult = await window.exodus.algorand.signTransaction([txn]);
                    return exodusResult[0];

                default:
                    throw new Error('Unknown wallet type');
            }
        }

        // Create and sign a wager payment transaction
        async function createWagerTransaction(receiverAddress, amountInAlgo, note = '') {
            const suggestedParams = await algodClient.getTransactionParams().do();

            const txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
                from: GameState.wallet.address,
                to: receiverAddress,
                amount: Math.floor(amountInAlgo * 1000000), // Convert ALGO to microAlgos
                note: new Uint8Array(Buffer.from(note)),
                suggestedParams
            });

            return txn;
        }

        // Send signed transaction to network
        async function sendTransaction(signedTxn) {
            const { txId } = await algodClient.sendRawTransaction(signedTxn).do();
            console.log('Transaction sent:', txId);

            // Wait for confirmation
            const result = await algosdk.waitForConfirmation(algodClient, txId, 4);
            console.log('Transaction confirmed in round:', result['confirmed-round']);

            return { txId, confirmedRound: result['confirmed-round'] };
        }

        // ============================================
        // API FUNCTIONS
        // ============================================

        // Fetch player stats from worker
        async function fetchPlayerStats(address) {
            try {
                const response = await fetch(
                    `${ALGO_CONFIG.WORKER_URL}/api/player-stats?address=${address}`
                );
                const data = await response.json();

                if (data && !data.error) {
                    GameState.stats.wins = data.wins || 0;
                    GameState.stats.losses = data.losses || 0;
                    GameState.stats.rating = data.rating || 1200;

                    // Update UI
                    DOM.statWins.textContent = GameState.stats.wins;
                    DOM.statLosses.textContent = GameState.stats.losses;
                    DOM.statRating.textContent = GameState.stats.rating;
                }
            } catch (error) {
                console.error('Error fetching player stats:', error);
            }
        }

        // Find match via worker API
        async function findMatchAPI() {
            try {
                const response = await fetch(`${ALGO_CONFIG.WORKER_URL}/api/find-match`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        address: GameState.wallet.address,
                        wager: GameState.match.wager,
                        rating: GameState.stats.rating,
                        gameMode: GameState.lobby.selectedMode
                    })
                });

                return await response.json();
            } catch (error) {
                console.error('Error finding match:', error);
                throw error;
            }
        }

        // Poll for match status
        async function pollMatchAPI() {
            try {
                const response = await fetch(`${ALGO_CONFIG.WORKER_URL}/api/poll-match`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        address: GameState.wallet.address
                    })
                });

                return await response.json();
            } catch (error) {
                console.error('Error polling match:', error);
                throw error;
            }
        }

        // Cancel search
        async function cancelSearchAPI() {
            try {
                const response = await fetch(`${ALGO_CONFIG.WORKER_URL}/api/cancel-search`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        address: GameState.wallet.address
                    })
                });

                return await response.json();
            } catch (error) {
                console.error('Error cancelling search:', error);
            }
        }

        // Submit move to server
        async function submitMoveAPI(gameId, move) {
            try {
                const response = await fetch(`${ALGO_CONFIG.WORKER_URL}/api/make-move`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gameId,
                        address: GameState.wallet.address,
                        move
                    })
                });

                return await response.json();
            } catch (error) {
                console.error('Error submitting move:', error);
                throw error;
            }
        }

        // Get game state from server
        async function getGameStateAPI(gameId) {
            try {
                const response = await fetch(
                    `${ALGO_CONFIG.WORKER_URL}/api/game-state?gameId=${gameId}&address=${GameState.wallet.address}`
                );

                return await response.json();
            } catch (error) {
                console.error('Error getting game state:', error);
                throw error;
            }
        }

        // Get leaderboard
        async function getLeaderboardAPI() {
            try {
                const response = await fetch(`${ALGO_CONFIG.WORKER_URL}/api/leaderboard`);
                return await response.json();
            } catch (error) {
                console.error('Error fetching leaderboard:', error);
                return { leaderboard: [] };
            }
        }

        // ============================================
        // ACTIVE GAMES FUNCTIONS
        // ============================================
        function renderActiveGames() {
            if (GameState.activeGames.length === 0) {
                DOM.activeGamesPanel.style.display = 'none';
                return;
            }

            DOM.activeGamesPanel.style.display = 'block';
            
            let html = '';
            GameState.activeGames.forEach((game, index) => {
                const turnClass = game.isMyTurn ? 'your-turn' : 'their-turn';
                const turnText = game.isMyTurn ? 'ðŸŸ¢ YOUR TURN' : 'â³ Their turn';
                const turnTextClass = game.isMyTurn ? 'you' : 'them';
                const sticksLeft = game.board.flat().filter(s => s).length;
                const timeSinceMove = Date.now() - game.lastMoveTime;
                const showReminder = game.isMyTurn && timeSinceMove > 5 * 60 * 1000; // 5 min for demo
                
                html += `
                    <div class="active-game-item ${turnClass}" onclick="switchToGame(${index})">
                        <div class="active-game-header">
                            <span class="active-game-opponent">vs ${game.opponent.substring(0, 8)}...</span>
                            <span class="active-game-pot">${game.pot.toFixed(4)} ALGO</span>
                        </div>
                        <div class="active-game-status">
                            <span class="active-game-turn ${turnTextClass}">${turnText}</span>
                            <span class="active-game-sticks">${sticksLeft} sticks left</span>
                        </div>
                        ${!game.isMyTurn && timeSinceMove > 10 * 60 * 1000 ? '<span class="reminder-badge">Reminder sent</span>' : ''}
                    </div>
                `;
            });

            DOM.activeGamesList.innerHTML = html;
        }

        function switchToGame(index) {
            if (index < 0 || index >= GameState.activeGames.length) return;
            
            const game = GameState.activeGames[index];
            GameState.currentGameIndex = index;
            
            // Load game state
            GameState.match = {
                active: true,
                gameId: game.gameId,
                opponent: game.opponent,
                wager: game.wager,
                pot: game.pot,
                isMyTurn: game.isMyTurn
            };
            GameState.board = JSON.parse(JSON.stringify(game.board)); // Deep copy
            GameState.selection.row = null;
            GameState.selection.sticks = [];
            
            // Show game board
            DOM.welcomeScreen.style.display = 'none';
            DOM.gameBoard.classList.add('active');
            DOM.potAmount.textContent = game.pot.toFixed(4);
            DOM.opponentAddress.textContent = game.opponent.substring(0, 10) + '...';
            
            renderBoard();
            updateTurnIndicator();
        }

        function saveCurrentGame() {
            if (GameState.currentGameIndex === null || !GameState.match.active) return;
            
            GameState.activeGames[GameState.currentGameIndex] = {
                ...GameState.activeGames[GameState.currentGameIndex],
                board: JSON.parse(JSON.stringify(GameState.board)),
                isMyTurn: GameState.match.isMyTurn,
                lastMoveTime: Date.now()
            };
            
            renderActiveGames();
        }

        // ============================================
        // ALGORAND TRANSACTION NOTES
        // ============================================
        function generateWinNote(winCondition, gameMode, opponent, pot) {
            // This note is attached to the ALGO payment to the winner
            const notes = {
                'opponent_last_stick': `AlgoNim WIN | Opponent took last stick | ${gameMode} | vs ${opponent.substring(0,8)}... | +${pot} ALGO | algonim.pages.dev`,
                'opponent_timeout': `AlgoNim WIN | Opponent timeout | ${gameMode} | vs ${opponent.substring(0,8)}... | +${pot} ALGO | algonim.pages.dev`,
                'opponent_abandon': `AlgoNim WIN | Opponent abandoned | ${gameMode} | vs ${opponent.substring(0,8)}... | +${pot} ALGO | algonim.pages.dev`,
            };
            return notes[winCondition] || `AlgoNim WIN | ${gameMode} | +${pot} ALGO`;
        }

        function generateLossNote(lossCondition, gameMode, opponent, amount) {
            // This could be logged or shown, funds go to winner
            const notes = {
                'took_last_stick': `AlgoNim LOSS | You took last stick | ${gameMode} | vs ${opponent.substring(0,8)}...`,
                'timeout': `AlgoNim LOSS | Timeout | ${gameMode} | vs ${opponent.substring(0,8)}...`,
                'abandon': `AlgoNim LOSS | Forfeit (idle 3 days) | ${gameMode} | vs ${opponent.substring(0,8)}...`,
            };
            return notes[lossCondition] || `AlgoNim LOSS | ${gameMode}`;
        }

        // ============================================
        // INVITE SYSTEM
        // ============================================
        async function sendGameInvite(toAddress, wager, gameMode) {
            if (!GameState.wallet.connected) {
                alert('Connect your wallet first!');
                return false;
            }

            // Validate Algorand address (58 chars, starts with valid chars)
            if (!toAddress || toAddress.length !== 58) {
                alert('Invalid Algorand address. Must be 58 characters.');
                return false;
            }

            const inviteNote = `AlgoNim INVITE | ${GameState.wallet.address.substring(0,8)}... challenges you! | Wager: ${wager} ALGO | Mode: ${gameMode} | Play at: algonim.pages.dev`;
            
            console.log(`[INVITE] Sending invite to ${toAddress}`);
            console.log(`[INVITE] Note: ${inviteNote}`);

            // In production, this calls your worker API which:
            // 1. Sends 0.001 ALGO from deployer wallet to toAddress with the invite note
            // 2. Creates a pending game in the database
            // 3. Returns a game invite ID

            /*
            const response = await fetch(WORKER_URL + '/api/invite', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    from: GameState.wallet.address,
                    to: toAddress,
                    wager: wager,
                    gameMode: gameMode,
                    note: inviteNote
                })
            });
            
            const result = await response.json();
            if (result.success) {
                // Add to pending invites
                GameState.pendingInvites.push({
                    inviteId: result.inviteId,
                    to: toAddress,
                    wager: wager,
                    gameMode: gameMode,
                    sentAt: Date.now()
                });
                return result.inviteId;
            }
            */

            // Simulated success for demo
            const inviteId = 'invite_' + Date.now();
            GameState.pendingInvites = GameState.pendingInvites || [];
            GameState.pendingInvites.push({
                inviteId: inviteId,
                to: toAddress,
                wager: wager,
                gameMode: gameMode,
                sentAt: Date.now(),
                status: 'pending'
            });
            
            renderPendingInvites();
            return inviteId;
        }

        async function acceptInvite(inviteId, fromAddress, wager, gameMode) {
            // Called when someone clicks an invite link or accepts from their wallet
            console.log(`[INVITE] Accepting invite ${inviteId} from ${fromAddress}`);

            /*
            const response = await fetch(WORKER_URL + '/api/invite/accept', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    inviteId: inviteId,
                    accepter: GameState.wallet.address
                })
            });
            */

            // Start the game with the inviter
            GameState.match.wager = wager;
            GameState.lobby.selectedMode = gameMode;
            startGameWithOpponent(fromAddress, 1200);
        }

        function renderPendingInvites() {
            if (!GameState.pendingInvites || GameState.pendingInvites.length === 0) {
                DOM.pendingInvitesPanel.style.display = 'none';
                return;
            }

            DOM.pendingInvitesPanel.style.display = 'block';
            
            let html = '';
            GameState.pendingInvites.forEach((invite, idx) => {
                const timeAgo = Math.floor((Date.now() - invite.sentAt) / 60000);
                html += `
                    <div class="invite-item">
                        <div class="invite-info">
                            <div class="invite-to">To: ${invite.to.substring(0,10)}...</div>
                            <div class="invite-details">${invite.wager} ALGO | ${invite.gameMode} | ${timeAgo}m ago</div>
                        </div>
                        <div class="invite-status ${invite.status}">${invite.status}</div>
                    </div>
                `;
            });

            DOM.pendingInvitesList.innerHTML = html;
        }

        // ============================================
        // FRIENDS SYSTEM
        // ============================================
        function renderFriendsDropdown() {
            if (!GameState.wallet.connected) return;

            // Update badge
            const onlineFriends = GameState.friends.filter(() => Math.random() > 0.5).length;
            if (onlineFriends > 0) {
                DOM.friendsBadge.textContent = onlineFriends;
                DOM.friendsBadge.classList.remove('hidden');
            } else {
                DOM.friendsBadge.classList.add('hidden');
            }

            if (GameState.friends.length === 0) {
                DOM.friendsDropdownList.innerHTML = '<div class="dropdown-empty">No friends yet. Add some!</div>';
                return;
            }

            let html = '';
            GameState.friends.forEach((friend, idx) => {
                const isOnline = Math.random() > 0.5;
                html += `
                    <div class="dropdown-item">
                        <div class="dropdown-item-info">
                            <div class="dropdown-avatar">ðŸ‘¤</div>
                            <div>
                                <div class="dropdown-name">${friend.nickname || friend.address.substring(0,8) + '...'}</div>
                                <div class="dropdown-detail" style="color:${isOnline ? 'var(--neon-green)' : '#666'}">${isOnline ? 'â— Online' : 'â—‹ Offline'}</div>
                            </div>
                        </div>
                        <div class="dropdown-actions">
                            <button class="dropdown-btn challenge" onclick="challengeFriend(${idx})">âš”ï¸</button>
                        </div>
                    </div>
                `;
            });

            DOM.friendsDropdownList.innerHTML = html;
        }

        function renderChallengesDropdown() {
            // Update badge
            if (GameState.incomingInvites.length > 0) {
                DOM.challengesBadge.textContent = GameState.incomingInvites.length;
                DOM.challengesBadge.classList.remove('hidden');
            } else {
                DOM.challengesBadge.classList.add('hidden');
            }

            if (GameState.incomingInvites.length === 0) {
                DOM.challengesDropdownList.innerHTML = '<div class="dropdown-empty">No pending challenges</div>';
                return;
            }
            
            let html = '';
            GameState.incomingInvites.forEach((invite, idx) => {
                const timeAgo = Math.floor((Date.now() - invite.receivedAt) / 60000);
                const fromDisplay = invite.fromNickname || invite.from.substring(0,10) + '...';
                html += `
                    <div class="dropdown-item">
                        <div class="dropdown-item-info">
                            <div class="dropdown-avatar" style="background:linear-gradient(135deg, var(--neon-magenta), #ff8c00);">âš”ï¸</div>
                            <div>
                                <div class="dropdown-name">${fromDisplay}</div>
                                <div class="dropdown-detail">${invite.wager} ALGO â€¢ ${invite.gameMode} â€¢ ${timeAgo}m ago</div>
                            </div>
                        </div>
                        <div class="dropdown-actions">
                            <button class="dropdown-btn accept" onclick="acceptIncomingInvite(${idx})">âœ“</button>
                            <button class="dropdown-btn decline" onclick="declineIncomingInvite(${idx})">âœ•</button>
                        </div>
                    </div>
                `;
            });

            DOM.challengesDropdownList.innerHTML = html;
        }

        // Legacy function names for compatibility
        function renderFriends() { renderFriendsDropdown(); }
        function renderIncomingInvites() { renderChallengesDropdown(); }

        function addFriend(address, nickname) {
            if (!address || address.length !== 58) {
                alert('Invalid Algorand address');
                return false;
            }

            // Check if already friends
            if (GameState.friends.find(f => f.address === address)) {
                alert('Already in your friends list!');
                return false;
            }

            GameState.friends.push({
                address: address,
                nickname: nickname || null,
                addedAt: Date.now()
            });

            renderFriends();
            closeAddFriendModal();
            return true;
        }

        function removeFriend(index) {
            if (confirm('Remove this friend?')) {
                GameState.friends.splice(index, 1);
                renderFriends();
            }
        }

        function challengeFriend(index) {
            const friend = GameState.friends[index];
            if (!friend) return;

            // Pre-fill invite with friend's address
            DOM.inviteAddressInput.value = friend.address;
            DOM.inviteWagerDisplay.textContent = GameState.match.wager + ' ALGO';
            DOM.inviteModeDisplay.textContent = GAME_MODES[GameState.lobby.selectedMode].name;
            openInviteModal();
        }

        function acceptIncomingInvite(index) {
            const invite = GameState.incomingInvites[index];
            if (!invite) return;

            // Remove from incoming
            GameState.incomingInvites.splice(index, 1);
            renderIncomingInvites();

            // Auto-add to friends if not already
            if (!GameState.friends.find(f => f.address === invite.from)) {
                GameState.friends.push({
                    address: invite.from,
                    nickname: invite.fromNickname || null,
                    addedAt: Date.now()
                });
                renderFriends();
            }

            // Start the game
            GameState.match.wager = invite.wager;
            GameState.lobby.selectedMode = invite.gameMode;
            startGameWithOpponent(invite.from, invite.fromRating || 1200);
        }

        function declineIncomingInvite(index) {
            GameState.incomingInvites.splice(index, 1);
            renderIncomingInvites();
        }

        function openAddFriendModal() {
            DOM.addFriendModal.classList.add('active');
        }

        function closeAddFriendModal() {
            DOM.addFriendModal.classList.remove('active');
            DOM.friendAddressInput.value = '';
            DOM.friendNicknameInput.value = '';
        }

        // Simulate receiving an invite (for demo)
        function simulateIncomingInvite() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            let addr = '';
            for (let i = 0; i < 58; i++) addr += chars.charAt(Math.floor(Math.random() * chars.length));
            
            GameState.incomingInvites.push({
                inviteId: 'inv_' + Date.now(),
                from: addr,
                fromNickname: null,
                fromRating: 1100 + Math.floor(Math.random() * 500),
                wager: [0.0001, 0.001, 0.01][Math.floor(Math.random() * 3)],
                gameMode: ['CASUAL', 'SPEED', 'BLITZ'][Math.floor(Math.random() * 3)],
                receivedAt: Date.now()
            });
            
            renderIncomingInvites();
        }

        function openInviteModal() {
            if (!GameState.wallet.connected) {
                alert('Connect your wallet first!');
                return;
            }
            DOM.inviteModal.classList.add('active');
        }

        function closeInviteModal() {
            DOM.inviteModal.classList.remove('active');
            DOM.inviteAddressInput.value = '';
        }

        async function submitInvite() {
            const address = DOM.inviteAddressInput.value.trim();
            const wager = GameState.match.wager;
            const mode = GameState.lobby.selectedMode;

            if (!address) {
                alert('Enter a wallet address');
                return;
            }

            const inviteId = await sendGameInvite(address, wager, mode);
            if (inviteId) {
                closeInviteModal();
                DOM.matchStatus.textContent = `Invite sent! Waiting for ${address.substring(0,8)}...`;
            }
        }

        // ============================================
        // TIMER SYSTEM
        // ============================================
        function startTurnTimer() {
            const mode = GAME_MODES[GameState.match.gameMode];
            if (!mode.turnTimeMs) {
                // Casual mode - no timer
                DOM.timerDisplay.style.display = 'none';
                return;
            }

            GameState.match.turnStartTime = Date.now();
            DOM.timerDisplay.style.display = 'flex';
            DOM.timerDisplay.classList.remove('warning', 'critical');
            DOM.timerMs.classList.remove('visible');
            DOM.timerModeBadge.textContent = mode.name.toUpperCase();
            
            // Clear existing interval
            if (GameState.match.timerInterval) {
                clearInterval(GameState.match.timerInterval);
            }

            // Update timer every 50ms for smooth countdown
            GameState.match.timerInterval = setInterval(() => {
                updateTimerDisplay();
            }, 50);
            
            // Initial update
            updateTimerDisplay();
        }

        function stopTurnTimer() {
            if (GameState.match.timerInterval) {
                clearInterval(GameState.match.timerInterval);
                GameState.match.timerInterval = null;
            }
            DOM.timerDisplay.style.display = 'none';
            DOM.timerDisplay.classList.remove('warning', 'critical');
        }

        function updateTimerDisplay() {
            const mode = GAME_MODES[GameState.match.gameMode];
            if (!mode.turnTimeMs || !GameState.match.turnStartTime) return;

            const elapsed = Date.now() - GameState.match.turnStartTime;
            const remaining = Math.max(0, mode.turnTimeMs - elapsed);
            
            // Calculate time components
            const totalSeconds = remaining / 1000;
            const mins = Math.floor(totalSeconds / 60);
            const secs = Math.floor(totalSeconds % 60);
            const ms = Math.floor((remaining % 1000) / 10);
            
            // Update display
            DOM.timerValue.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            DOM.timerMs.textContent = `.${ms.toString().padStart(2, '0')}`;

            // Reset classes
            DOM.timerDisplay.classList.remove('warning', 'critical');
            DOM.timerMs.classList.remove('visible');
            
            // Color coding based on time remaining
            if (remaining <= 10000) {
                // Last 10 seconds - CRITICAL (red, show ms, shake)
                DOM.timerDisplay.classList.add('critical');
                DOM.timerMs.classList.add('visible');
            } else if (remaining <= 20000) {
                // Last 20 seconds - WARNING (yellow)
                DOM.timerDisplay.classList.add('warning');
            }

            // Play tick sound effect in last 10 seconds (visual only for now)
            if (remaining <= 10000 && remaining > 0) {
                // Could add audio tick here
            }

            // Time's up!
            if (remaining <= 0) {
                DOM.timerValue.textContent = '0:00';
                DOM.timerMs.textContent = '.00';
                handleTimeout();
            }
        }

        function handleTimeout() {
            stopTurnTimer();
            
            if (GameState.match.isMyTurn) {
                // I timed out - I lose
                endGameByTimeout(false);
            } else {
                // Opponent timed out - I win
                endGameByTimeout(true);
            }
        }

        function endGameByTimeout(didWin) {
            GameState.match.active = false;
            
            // Remove from active games
            if (GameState.currentGameIndex !== null) {
                GameState.activeGames.splice(GameState.currentGameIndex, 1);
                GameState.currentGameIndex = null;
            }
            
            const modeName = GAME_MODES[GameState.match.gameMode]?.name || 'Speed';
            let txnNote = '';
            
            if (didWin) {
                GameState.stats.wins++;
                GameState.stats.earnings += GameState.match.wager;
                GameState.stats.rating += PENALTIES.WIN_BY_TIMEOUT;
                GameState.wallet.balance += GameState.match.wager;
                
                txnNote = generateWinNote('opponent_timeout', modeName, GameState.match.opponent, GameState.match.pot.toFixed(4));
                console.log(`[TXN NOTE] Winner receives: ${txnNote}`);
                
                DOM.resultIcon.textContent = 'â±ï¸';
                DOM.resultTitle.textContent = 'YOU WIN!';
                DOM.resultTitle.className = 'modal-title win';
                DOM.resultAmount.textContent = `+${GameState.match.pot.toFixed(4)} ALGO`;
                DOM.resultAmount.className = 'modal-amount positive';
                DOM.resultMessage.textContent = `Won by: Opponent timeout | Mode: ${modeName}`;
            } else {
                GameState.stats.losses++;
                GameState.stats.earnings -= GameState.match.wager;
                GameState.stats.rating += PENALTIES.TIMEOUT;
                GameState.wallet.balance -= GameState.match.wager;
                
                txnNote = generateLossNote('timeout', modeName, GameState.match.opponent, GameState.match.wager);
                console.log(`[TXN NOTE] Loser record: ${txnNote}`);
                
                DOM.resultIcon.textContent = 'â±ï¸';
                DOM.resultTitle.textContent = 'TIME OUT!';
                DOM.resultTitle.className = 'modal-title lose';
                DOM.resultAmount.textContent = `-${GameState.match.wager.toFixed(4)} ALGO`;
                DOM.resultAmount.className = 'modal-amount negative';
                DOM.resultMessage.textContent = `Lost by: Timeout | Mode: ${modeName}`;
            }
            
            // Update displays
            DOM.statWins.textContent = GameState.stats.wins;
            DOM.statLosses.textContent = GameState.stats.losses;
            DOM.statRating.textContent = Math.max(0, GameState.stats.rating);
            DOM.statEarnings.textContent = GameState.stats.earnings.toFixed(2);
            
            renderActiveGames();
            DOM.resultModal.classList.add('active');
        }

        function endGameByAbandon(didWin) {
            // Called when opponent abandons after 3 days
            GameState.match.active = false;
            
            if (GameState.currentGameIndex !== null) {
                GameState.activeGames.splice(GameState.currentGameIndex, 1);
                GameState.currentGameIndex = null;
            }
            
            const modeName = GAME_MODES[GameState.match.gameMode]?.name || 'Casual';
            let txnNote = '';
            
            if (didWin) {
                GameState.stats.wins++;
                GameState.stats.earnings += GameState.match.wager;
                GameState.stats.rating += PENALTIES.WIN_BY_ABANDON;
                GameState.wallet.balance += GameState.match.wager;
                
                txnNote = generateWinNote('opponent_abandon', modeName, GameState.match.opponent, GameState.match.pot.toFixed(4));
                console.log(`[TXN NOTE] Winner receives: ${txnNote}`);
                
                DOM.resultIcon.textContent = 'ðŸƒ';
                DOM.resultTitle.textContent = 'YOU WIN!';
                DOM.resultTitle.className = 'modal-title win';
                DOM.resultAmount.textContent = `+${GameState.match.pot.toFixed(4)} ALGO`;
                DOM.resultAmount.className = 'modal-amount positive';
                DOM.resultMessage.textContent = `Won by: Opponent abandoned (3 days idle) | Mode: ${modeName}`;
            } else {
                // This would only happen if server detects OUR abandon
                GameState.stats.losses++;
                GameState.stats.earnings -= GameState.match.wager;
                GameState.stats.rating += PENALTIES.ABANDON;
                GameState.wallet.balance -= GameState.match.wager;
                
                txnNote = generateLossNote('abandon', modeName, GameState.match.opponent, GameState.match.wager);
                console.log(`[TXN NOTE] Loser record: ${txnNote}`);
                
                DOM.resultIcon.textContent = 'ðŸƒ';
                DOM.resultTitle.textContent = 'FORFEITED';
                DOM.resultTitle.className = 'modal-title lose';
                DOM.resultAmount.textContent = `-${GameState.match.wager.toFixed(4)} ALGO`;
                DOM.resultAmount.className = 'modal-amount negative';
                DOM.resultMessage.textContent = `Lost by: Forfeit (3 days idle) | Mode: ${modeName}`;
            }
            
            DOM.statWins.textContent = GameState.stats.wins;
            DOM.statLosses.textContent = GameState.stats.losses;
            DOM.statRating.textContent = Math.max(0, GameState.stats.rating);
            DOM.statEarnings.textContent = GameState.stats.earnings.toFixed(2);
            
            renderActiveGames();
            DOM.resultModal.classList.add('active');
        }

        function selectGameMode(mode) {
            GameState.lobby.selectedMode = mode;
            DOM.modeOptions.forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.mode === mode);
            });
        }

        // ============================================
        // LOBBY FUNCTIONS
        // ============================================
        function renderLobby() {
            if (!GameState.wallet.connected) {
                DOM.lobbyList.innerHTML = '<div class="lobby-empty">Connect wallet to see open matches</div>';
                return;
            }

            // Filter players by selected wager (or show all)
            const players = simulatedLobbyPlayers;
            
            if (players.length === 0 && !GameState.lobby.waiting) {
                DOM.lobbyList.innerHTML = '<div class="lobby-empty">No open matches. Create one!</div>';
                return;
            }

            let html = '';

            // Show our waiting entry first if we're waiting
            if (GameState.lobby.waiting) {
                html += `
                    <div class="lobby-item" style="border-color: var(--neon-green);">
                        <div class="lobby-player">
                            <div class="lobby-avatar" style="background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));">ðŸ‘¤</div>
                            <div class="lobby-info">
                                <div class="lobby-address">${GameState.wallet.address.substring(0, 10)}...</div>
                                <div class="lobby-rating">Rating: ${GameState.stats.rating}</div>
                            </div>
                        </div>
                        <div class="lobby-wager">
                            <div class="lobby-amount">${GameState.match.wager} ALGO</div>
                            <div class="waiting-indicator">
                                <div class="waiting-dot"></div>
                                <span>Waiting...</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Show other players
            players.forEach(player => {
                html += `
                    <div class="lobby-item">
                        <div class="lobby-player">
                            <div class="lobby-avatar">ðŸ‘¤</div>
                            <div class="lobby-info">
                                <div class="lobby-address">${player.address}</div>
                                <div class="lobby-rating">Rating: ${player.rating}</div>
                            </div>
                        </div>
                        <div class="lobby-wager">
                            <div class="lobby-amount">${player.wager} ALGO</div>
                            <button class="lobby-join" onclick="joinMatch(${player.id}, '${player.address}', ${player.wager}, ${player.rating})">JOIN</button>
                        </div>
                    </div>
                `;
            });

            DOM.lobbyList.innerHTML = html;
        }

        function joinMatch(playerId, address, wager, rating) {
            if (!GameState.wallet.connected) return;
            
            // Cancel our waiting if we were waiting
            if (GameState.lobby.waiting) {
                cancelWaiting();
            }

            GameState.match.wager = wager;
            
            // Start game immediately with this opponent
            startGameWithOpponent(address, rating);
        }

        function startGameWithOpponent(oppAddress, oppRating) {
            const newGame = {
                gameId: 'game_' + Date.now(),
                opponent: oppAddress,
                opponentRating: oppRating || 1200,
                wager: GameState.match.wager,
                pot: GameState.match.wager * 2,
                isMyTurn: Math.random() > 0.5,
                gameMode: GameState.lobby.selectedMode,
                board: [
                    [true],
                    [true, true, true],
                    [true, true, true, true, true],
                    [true, true, true, true, true, true, true]
                ],
                lastMoveTime: Date.now(),
                reminderSent: false
            };
            
            // Add to active games
            GameState.activeGames.push(newGame);
            GameState.currentGameIndex = GameState.activeGames.length - 1;
            
            GameState.match.active = true;
            GameState.match.gameId = newGame.gameId;
            GameState.match.opponent = oppAddress;
            GameState.match.pot = newGame.pot;
            GameState.match.isMyTurn = newGame.isMyTurn;
            GameState.match.gameMode = newGame.gameMode;
            
            // Reset board
            GameState.board = JSON.parse(JSON.stringify(newGame.board));
            GameState.selection.row = null;
            GameState.selection.sticks = [];
            
            // Update UI
            DOM.welcomeScreen.style.display = 'none';
            DOM.gameBoard.classList.add('active');
            DOM.potAmount.textContent = newGame.pot.toFixed(4);
            DOM.opponentAddress.textContent = oppAddress.substring(0, 10) + '...';
            DOM.findMatchBtn.classList.remove('searching');
            DOM.findMatchBtn.textContent = 'NEW MATCH';
            DOM.findMatchBtn.disabled = false;
            DOM.matchStatus.textContent = `${GameState.activeGames.length} active game(s)`;
            
            renderBoard();
            updateTurnIndicator();
            renderActiveGames();
            
            // Start timer if speed mode
            if (GameState.match.isMyTurn) {
                startTurnTimer();
            }
            
            // If opponent's turn first, simulate their move
            if (!GameState.match.isMyTurn) {
                setTimeout(simulateOpponentMove, 2000);
            }
        }

        function cancelWaiting() {
            GameState.lobby.waiting = false;
            GameState.lobby.waitingId = null;
            DOM.findMatchBtn.classList.remove('searching');
            DOM.findMatchBtn.textContent = 'FIND MATCH';
            DOM.matchStatus.textContent = 'Ready to play!';
            renderLobby();
        }

        // ============================================
        // MATCHMAKING FUNCTIONS
        // ============================================
        function selectWager(wager) {
            GameState.match.wager = parseFloat(wager);
            DOM.wagerOptions.forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.wager === wager);
            });
        }

        function findMatch() {
            if (!GameState.wallet.connected) return;
            
            if (GameState.lobby.waiting) {
                // Cancel waiting
                cancelWaiting();
                return;
            }
            
            // Add ourselves to lobby and wait
            GameState.lobby.waiting = true;
            GameState.lobby.waitingId = Date.now();
            
            DOM.findMatchBtn.classList.add('searching');
            DOM.findMatchBtn.textContent = 'CANCEL';
            DOM.matchStatus.textContent = 'Waiting for opponent...';
            
            renderLobby();
            
            // Simulate someone joining after random delay (5-15 seconds)
            // In production, this would be handled by the server
            setTimeout(() => {
                if (GameState.lobby.waiting && !GameState.match.active) {
                    // Someone found us!
                    GameState.lobby.waiting = false;
                    startGame();
                }
            }, 5000 + Math.random() * 10000);
        }

        // ============================================
        // GAME FUNCTIONS
        // ============================================
        function startGame() {
            // Generate opponent
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            let oppAddress = '';
            for (let i = 0; i < 58; i++) {
                oppAddress += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            
            GameState.match.active = true;
            GameState.match.gameId = 'game_' + Date.now();
            GameState.match.opponent = oppAddress;
            GameState.match.pot = GameState.match.wager * 2;
            GameState.match.isMyTurn = Math.random() > 0.5;
            
            // Reset board - each stick tracked individually
            GameState.board = [
                [true],
                [true, true, true],
                [true, true, true, true, true],
                [true, true, true, true, true, true, true]
            ];
            GameState.selection.row = null;
            GameState.selection.sticks = [];
            
            // Update UI
            DOM.welcomeScreen.style.display = 'none';
            DOM.gameBoard.classList.add('active');
            DOM.potAmount.textContent = GameState.match.pot.toFixed(4);
            DOM.opponentAddress.textContent = oppAddress.substring(0, 8) + '...';
            DOM.findMatchBtn.classList.remove('searching');
            DOM.findMatchBtn.textContent = 'IN GAME';
            DOM.matchStatus.textContent = 'Game in progress';
            
            renderBoard();
            updateTurnIndicator();
            
            // If opponent's turn first, simulate their move
            if (!GameState.match.isMyTurn) {
                setTimeout(simulateOpponentMove, 2000);
            }
        }

        function renderBoard() {
            const rowSizes = [1, 3, 5, 7];
            let stickIndex = 0;
            
            for (let row = 0; row < 4; row++) {
                for (let i = 0; i < rowSizes[row]; i++) {
                    const stick = DOM.sticks[stickIndex];
                    const isRemoved = !GameState.board[row][i];
                    const isSelected = GameState.selection.row === row && 
                                      GameState.selection.sticks.includes(i);
                    
                    stick.classList.toggle('removed', isRemoved);
                    stick.classList.toggle('selected', isSelected && !isRemoved);
                    stick.classList.toggle('disabled', !GameState.match.isMyTurn);
                    
                    stickIndex++;
                }
            }
        }

        function updateTurnIndicator() {
            const pyramid = document.getElementById('nimPyramid');

            if (GameState.match.isMyTurn) {
                DOM.turnIndicator.textContent = 'YOUR TURN';
                DOM.turnIndicator.className = 'turn-indicator your-turn';
                DOM.selectionInfo.textContent = 'Click sticks to select (from one row only)';
                pyramid.classList.remove('opponent-turn');
                pyramid.classList.add('your-turn');
            } else {
                DOM.turnIndicator.textContent = "OPPONENT'S TURN";
                DOM.turnIndicator.className = 'turn-indicator opponent-turn';
                DOM.selectionInfo.textContent = 'Waiting for opponent...';
                pyramid.classList.remove('your-turn');
                pyramid.classList.add('opponent-turn');
            }
            DOM.submitBtn.disabled = true;
        }

        function clickStick(row, index) {
            if (!GameState.match.isMyTurn) return;
            if (!GameState.board[row][index]) return; // Already removed
            
            // If clicking different row, reset selection
            if (GameState.selection.row !== null && GameState.selection.row !== row) {
                GameState.selection.sticks = [];
            }
            
            GameState.selection.row = row;
            
            // Toggle selection
            const idx = GameState.selection.sticks.indexOf(index);
            if (idx > -1) {
                GameState.selection.sticks.splice(idx, 1);
            } else {
                GameState.selection.sticks.push(index);
            }
            
            // Update UI
            renderBoard();
            
            if (GameState.selection.sticks.length > 0) {
                DOM.selectionInfo.textContent = 
                    `Selected ${GameState.selection.sticks.length} stick(s) from Row ${row + 1}`;
                DOM.submitBtn.disabled = false;
            } else {
                DOM.selectionInfo.textContent = 'Click sticks to select (from one row only)';
                DOM.submitBtn.disabled = true;
            }
        }

        // Create particle burst effect on stick
        function createParticleEffect(stickElement) {
            const colors = ['#00f5ff', '#ff006e', '#ffd700', '#39ff14', '#bf00ff'];
            const particleCount = 8;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';

                // Random direction
                const angle = (i / particleCount) * Math.PI * 2;
                const distance = 40 + Math.random() * 30;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;

                particle.style.cssText = `
                    --tx: ${tx}px;
                    --ty: ${ty}px;
                    background: ${colors[Math.floor(Math.random() * colors.length)]};
                    box-shadow: 0 0 10px currentColor;
                `;

                stickElement.appendChild(particle);

                // Remove particle after animation
                setTimeout(() => particle.remove(), 800);
            }

            // Add glow ring
            const ring = document.createElement('div');
            ring.className = 'stick-glow-ring';
            stickElement.appendChild(ring);
            setTimeout(() => ring.remove(), 500);
        }

        // Animate stick removal with effects
        function animateStickRemoval(stickElements, callback) {
            let delay = 0;
            const staggerDelay = 80; // ms between each stick animation

            stickElements.forEach((stick, index) => {
                setTimeout(() => {
                    stick.classList.remove('selected');
                    stick.classList.add('removing');
                    createParticleEffect(stick);
                }, delay);
                delay += staggerDelay;
            });

            // Call callback after all animations complete
            const totalTime = delay + 600; // 600ms is the animation duration
            setTimeout(callback, totalTime);
        }

        function submitMove() {
            if (GameState.selection.sticks.length === 0) return;

            const row = GameState.selection.row;
            const selectedIndices = [...GameState.selection.sticks];

            // Disable button immediately
            DOM.submitBtn.disabled = true;

            // Find the stick elements to animate
            const rowSizes = [1, 3, 5, 7];
            let baseIndex = 0;
            for (let r = 0; r < row; r++) {
                baseIndex += rowSizes[r];
            }

            const sticksToAnimate = selectedIndices.map(i => DOM.sticks[baseIndex + i]);

            // Animate the removal
            animateStickRemoval(sticksToAnimate, () => {
                // Mark selected sticks as removed in game state
                selectedIndices.forEach(index => {
                    GameState.board[row][index] = false;
                });

                // Reset selection
                GameState.selection.row = null;
                GameState.selection.sticks = [];

                // Stop my timer
                stopTurnTimer();

                // Check game over - count remaining sticks
                const total = GameState.board.flat().filter(s => s).length;
                if (total === 0) {
                    endGame(false); // I took last stick, I lose
                    return;
                }

                // Switch turn
                GameState.match.isMyTurn = false;
                renderBoard();
                updateTurnIndicator();

                // Save game state
                saveCurrentGame();

                // Simulate opponent (in production, this would be server-side)
                setTimeout(simulateOpponentMove, 1500 + Math.random() * 1000);
            });
        }

        function simulateOpponentMove() {
            if (!GameState.match.active || GameState.match.isMyTurn) return;

            // Find rows with remaining sticks
            const validRows = [];
            GameState.board.forEach((row, idx) => {
                const remaining = row.filter(s => s).length;
                if (remaining > 0) validRows.push(idx);
            });

            if (validRows.length === 0) return;

            // Pick random row
            const rowIdx = validRows[Math.floor(Math.random() * validRows.length)];
            const row = GameState.board[rowIdx];

            // Find available sticks in this row
            const availableIndices = [];
            row.forEach((present, idx) => {
                if (present) availableIndices.push(idx);
            });

            // Remove 1 to all available sticks randomly
            const removeCount = Math.floor(Math.random() * availableIndices.length) + 1;
            const toRemove = availableIndices.slice(0, removeCount);

            // Find stick elements to animate
            const rowSizes = [1, 3, 5, 7];
            let baseIndex = 0;
            for (let r = 0; r < rowIdx; r++) {
                baseIndex += rowSizes[r];
            }
            const sticksToAnimate = toRemove.map(i => DOM.sticks[baseIndex + i]);

            // Animate opponent's removal with magenta theme
            animateStickRemoval(sticksToAnimate, () => {
                // Mark them as removed
                toRemove.forEach(idx => {
                    GameState.board[rowIdx][idx] = false;
                });

                // Check game over
                const total = GameState.board.flat().filter(s => s).length;
                if (total === 0) {
                    endGame(true); // Opponent took last stick, I win!
                    return;
                }

                // My turn - start timer
                GameState.match.isMyTurn = true;
                renderBoard();
                updateTurnIndicator();
                startTurnTimer();
            });
        }

        // Create confetti celebration effect
        function createConfetti() {
            const container = document.createElement('div');
            container.className = 'confetti-container';
            document.body.appendChild(container);

            const colors = ['#00f5ff', '#ff006e', '#39ff14', '#ffd700', '#bf00ff', '#ffffff'];
            const confettiCount = 100;

            for (let i = 0; i < confettiCount; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';

                    // Random properties
                    const left = Math.random() * 100;
                    const size = 5 + Math.random() * 10;
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const duration = 2 + Math.random() * 2;
                    const delay = Math.random() * 0.5;

                    // Random shape
                    const shapes = ['50%', '0', '50% 0 50% 50%'];
                    const shape = shapes[Math.floor(Math.random() * shapes.length)];

                    confetti.style.cssText = `
                        left: ${left}%;
                        width: ${size}px;
                        height: ${size}px;
                        background: ${color};
                        border-radius: ${shape};
                        animation-duration: ${duration}s;
                        animation-delay: ${delay}s;
                        box-shadow: 0 0 ${size}px ${color};
                    `;

                    container.appendChild(confetti);
                }, i * 20);
            }

            // Remove container after animation
            setTimeout(() => container.remove(), 5000);
        }

        // Create victory glow flash
        function createVictoryGlow() {
            const glow = document.createElement('div');
            glow.className = 'victory-glow';
            document.body.appendChild(glow);
            setTimeout(() => glow.remove(), 800);
        }

        // Apply defeat shake to game area
        function applyDefeatShake() {
            const gameArea = document.querySelector('.game-area');
            gameArea.classList.add('defeat-shake');
            setTimeout(() => gameArea.classList.remove('defeat-shake'), 500);
        }

        function endGame(didWin) {
            GameState.match.active = false;
            stopTurnTimer();

            // Remove pyramid glow classes
            const pyramid = document.getElementById('nimPyramid');
            pyramid.classList.remove('your-turn', 'opponent-turn');

            // Remove from active games
            if (GameState.currentGameIndex !== null) {
                GameState.activeGames.splice(GameState.currentGameIndex, 1);
                GameState.currentGameIndex = null;
            }

            const modeName = GAME_MODES[GameState.match.gameMode]?.name || 'Casual';

            // Generate transaction note for winner's payment
            let txnNote = '';

            // Update stats and trigger celebration/defeat effects
            if (didWin) {
                // Victory effects
                createVictoryGlow();
                setTimeout(createConfetti, 200);

                GameState.stats.wins++;
                GameState.stats.earnings += GameState.match.wager;
                GameState.stats.rating += 15 + Math.floor(Math.random() * 10);
                GameState.wallet.balance += GameState.match.wager;

                txnNote = generateWinNote('opponent_last_stick', modeName, GameState.match.opponent, GameState.match.pot.toFixed(4));
                console.log(`[TXN NOTE] Winner receives: ${txnNote}`);

                DOM.resultIcon.textContent = 'ðŸŽ‰';
                DOM.resultTitle.textContent = 'YOU WIN!';
                DOM.resultTitle.className = 'modal-title win';
                DOM.resultAmount.textContent = `+${GameState.match.pot.toFixed(4)} ALGO`;
                DOM.resultAmount.className = 'modal-amount positive';
                DOM.resultMessage.textContent = `Won by: Opponent took last stick | Mode: ${modeName}`;
            } else {
                // Defeat effects
                applyDefeatShake();

                GameState.stats.losses++;
                GameState.stats.earnings -= GameState.match.wager;
                GameState.stats.rating -= 10 + Math.floor(Math.random() * 5);
                GameState.wallet.balance -= GameState.match.wager;

                txnNote = generateLossNote('took_last_stick', modeName, GameState.match.opponent, GameState.match.wager);
                console.log(`[TXN NOTE] Loser record: ${txnNote}`);

                DOM.resultIcon.textContent = 'ðŸ˜”';
                DOM.resultTitle.textContent = 'YOU LOSE';
                DOM.resultTitle.className = 'modal-title lose';
                DOM.resultAmount.textContent = `-${GameState.match.wager.toFixed(4)} ALGO`;
                DOM.resultAmount.className = 'modal-amount negative';
                DOM.resultMessage.textContent = `Lost by: You took last stick | Mode: ${modeName}`;
            }

            // Update displays
            DOM.statWins.textContent = GameState.stats.wins;
            DOM.statLosses.textContent = GameState.stats.losses;
            DOM.statRating.textContent = Math.max(0, GameState.stats.rating);
            DOM.statEarnings.textContent = GameState.stats.earnings.toFixed(2);

            // Update active games panel
            renderActiveGames();

            // Show modal with slight delay for effects
            setTimeout(() => {
                DOM.resultModal.classList.add('active');
            }, didWin ? 300 : 100);
        }

        function returnToLobby() {
            stopTurnTimer();
            DOM.resultModal.classList.remove('active');
            DOM.gameBoard.classList.remove('active');
            DOM.welcomeScreen.style.display = 'flex';
            DOM.findMatchBtn.disabled = false;
            DOM.findMatchBtn.textContent = 'FIND MATCH';
            DOM.matchStatus.textContent = 'Ready to play!';
            renderLobby();
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================
        DOM.connectBtn.addEventListener('click', () => {
            if (!GameState.wallet.connected) {
                openWalletModal();
            } else {
                // Already connected - offer to disconnect
                if (confirm('Disconnect wallet?')) {
                    disconnectWallet();
                }
            }
        });

        DOM.closeWalletModal.addEventListener('click', closeWalletModal);

        DOM.walletOptions.forEach(option => {
            option.addEventListener('click', () => {
                connectWallet(option.dataset.wallet);
            });
        });

        DOM.wagerOptions.forEach(option => {
            option.addEventListener('click', () => {
                selectWager(option.dataset.wager);
            });
        });

        DOM.modeOptions.forEach(option => {
            option.addEventListener('click', () => {
                selectGameMode(option.dataset.mode);
            });
        });

        DOM.findMatchBtn.addEventListener('click', findMatch);

        DOM.sticks.forEach(stick => {
            stick.addEventListener('click', () => {
                const row = parseInt(stick.dataset.row);
                const index = parseInt(stick.dataset.index);
                clickStick(row, index);
            });
        });

        DOM.submitBtn.addEventListener('click', submitMove);
        DOM.playAgainBtn.addEventListener('click', returnToLobby);
        DOM.closeResultX.addEventListener('click', returnToLobby);

        // Header dropdown toggles
        DOM.challengesBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            DOM.challengesDropdown.classList.toggle('active');
            DOM.friendsDropdown.classList.remove('active');
        });

        DOM.friendsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            DOM.friendsDropdown.classList.toggle('active');
            DOM.challengesDropdown.classList.remove('active');
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!DOM.challengesBtn.contains(e.target)) {
                DOM.challengesDropdown.classList.remove('active');
            }
            if (!DOM.friendsBtn.contains(e.target)) {
                DOM.friendsDropdown.classList.remove('active');
            }
        });

        // Invite modal
        DOM.closeInviteX.addEventListener('click', closeInviteModal);
        DOM.cancelInviteBtn.addEventListener('click', closeInviteModal);
        DOM.sendInviteBtn.addEventListener('click', submitInvite);
        DOM.inviteModal.addEventListener('click', (e) => {
            if (e.target === DOM.inviteModal) closeInviteModal();
        });

        // Friends system - add friend from header
        DOM.addFriendBtnHeader.addEventListener('click', openAddFriendModal);
        DOM.closeAddFriendX.addEventListener('click', closeAddFriendModal);
        DOM.cancelAddFriendBtn.addEventListener('click', closeAddFriendModal);
        DOM.confirmAddFriendBtn.addEventListener('click', () => {
            const address = DOM.friendAddressInput.value.trim();
            const nickname = DOM.friendNicknameInput.value.trim();
            addFriend(address, nickname);
        });
        DOM.addFriendModal.addEventListener('click', (e) => {
            if (e.target === DOM.addFriendModal) closeAddFriendModal();
        });

        // Close modals on overlay click
        DOM.walletModal.addEventListener('click', (e) => {
            if (e.target === DOM.walletModal) closeWalletModal();
        });

        DOM.resultModal.addEventListener('click', (e) => {
            if (e.target === DOM.resultModal) returnToLobby();
        });

        // ============================================
        // INITIALIZE
        // ============================================
        console.log('AlgoNim initialized. Click "Connect Wallet" to start playing!');
    </script>
</body>
</html>